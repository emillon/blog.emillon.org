<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Enter the void * - From OhLife to org-mode with Parsec</title>
        <link rel="stylesheet" type="text/css" href="../css/bootstrap.css" />
        <link rel="stylesheet" type="text/css" href="../css/extra.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="alternate" type="application/rss+xml" title="Enter the void *" href="../rss.xml" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link href="http://fonts.googleapis.com/css?family=Merriweather:400,300" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <div class="header container">
            <h1 class="maintitle">Enter the void *</h1>
               <div class="nav-hdr">
                   <ul>
                      <li><a href="../">Home</a></li>
                      <li><a href="../posts.html">All posts</a></li>
                      <li><a href="../rss.xml">Feed</a></li>
                      <li><a href="https://github.com/emillon">Github</a></li>
                      <li><a href="https://qa.debian.org/developer.php?login=me%40emillon.org">Debian</a></li>
                      <li><a href="https://twitter.com/etiennemillon">Twitter</a></li>
                   </ul>
                </div>
        </div>
        <div class="maincontainer container">
          <div class="col-md-8 col-md-offset-2">
            <h1>From OhLife to org-mode with Parsec</h1>

<p>by <em>Etienne Millon</em> on <strong>No date</strong></p>

<p>Tagged as: .</p>

<p>A few weeks ago, <a href="http://ohlife.com">OhLife</a> shut down. It is a shame, as I really loved the service. Every day, it sent you an email asking how you day was. You reply with a few words, or a few sentences, and it uploaded it into a (private) archive. But the really awesome feature is that the daily mail used to include a past random entry. So, you can realize that time passes…</p>
<p>Anyway, the service shut down and I could export my data before. I use <a href="http://orgmode.org/">org mode</a> to organize several other things (TODOs! agenda! playlists!), so I will try to use it for this from now on. Hosting snippets of my life in an external service was scary anyway :).</p>
<p>So, let’s write a conversion script. This is a good occasion to use <a href="http://www.haskell.org/haskellwiki/Parsec">Parsec</a>.</p>
<h2 id="parsing">Parsing</h2>
<p>(Insert explanation that this is a litterate haskell file)</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">import</span> <span class="dt">Control.Applicative</span> ((&lt;*), (*&gt;), (&lt;*&gt;), (&lt;$&gt;))</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">import</span> <span class="dt">Control.Monad</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">import</span> <span class="dt">Control.Monad.RWS</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">import</span> <span class="dt">Text.ParserCombinators.Parsec</span></a></code></pre></div>
<p>To parse things, you usually have several options:</p>
<ul>
<li>do it by hand. Split on separators, count character offsets, etc.</li>
<li>use regular expressions. Yeah, you have two problems. I read xkcd too.</li>
<li>use a LR parser generator such as <code>yacc</code> or <code>happy</code>.</li>
<li>use parser combinators.</li>
</ul>
<p>Parser generators have several drawbacks. First, they require to use a separate tool to generate code. Also, they tend to be quite slow. Finally, they are somewhat arcane to debug: sometimes you change an innocuous rule and get 30 shift/reduce conflicts. Good luck with that.</p>
<p>On the contrary, parser combinators are nice because they are written within the same implementation language as the rest of your code. They’re just functions. Suppose that a language has string litterals and integer litterals, and that both are constants. To define the rule for constants, you’ll just declare</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">constant <span class="fu">=</span> string_lit <span class="fu">&lt;|&gt;</span> integer_lit</a></code></pre></div>
<p>It’s very declarative. <code>(&lt;|&gt;)</code> takes two parsers and returns a new parser which can parse either. This property makes your code kind of look like the text you’re trying to parse.</p>
<p>For example, in the case of the OhLife export, the texts looks like:</p>
<pre><code>YYYY-MM-DD

Entry

YYYY-MM-DD

Entry</code></pre>
<p>And the (actual) code to parse it is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">entry ::</span> <span class="dt">Parser</span> <span class="dt">Entry</span></a>
<a class="sourceLine" id="cb4-2" title="2">entry <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-3" title="3">  d <span class="ot">&lt;-</span> date</a>
<a class="sourceLine" id="cb4-4" title="4">  eol</a>
<a class="sourceLine" id="cb4-5" title="5">  eol</a>
<a class="sourceLine" id="cb4-6" title="6">  l <span class="ot">&lt;-</span> body</a>
<a class="sourceLine" id="cb4-7" title="7">  <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Entry</span> d l</a></code></pre></div>
<p>And to parse several of them, we use the following code. We can remove the <code>eof</code> and the parser will parse till an error occur, but is is better to detect errors.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">entries ::</span> <span class="dt">Parser</span> [<span class="dt">Entry</span>]</a>
<a class="sourceLine" id="cb5-2" title="2">entries <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-3" title="3">    many1 entry <span class="fu">&lt;*</span> eof</a></code></pre></div>
<p>Of course we need to define the <code>Entry</code> data type.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">data</span> <span class="dt">Entry</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="dt">Entry</span> {<span class="ot"> entryDate ::</span> <span class="dt">Date</span></a>
<a class="sourceLine" id="cb6-3" title="3">          ,<span class="ot"> entryBody ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb6-4" title="4">          }</a>
<a class="sourceLine" id="cb6-5" title="5">        <span class="kw">deriving</span> (<span class="dt">Show</span>)</a></code></pre></div>
<p>Parsing a date is quite easy but needs a bit of explaining.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">data</span> <span class="dt">Date</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="dt">Date</span> {<span class="ot"> dateYear ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb7-3" title="3">         ,<span class="ot"> dateMonth ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb7-4" title="4">         ,<span class="ot"> dateDay ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb7-5" title="5">         }</a>
<a class="sourceLine" id="cb7-6" title="6">        <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb7-7" title="7"></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="ot">number ::</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb7-9" title="9">number <span class="fu">=</span> many1 digit</a>
<a class="sourceLine" id="cb7-10" title="10"></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="ot">date ::</span> <span class="dt">Parser</span> <span class="dt">Date</span></a>
<a class="sourceLine" id="cb7-12" title="12">date <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-13" title="13">    <span class="dt">Date</span> <span class="fu">&lt;$&gt;</span> (number <span class="fu">&lt;*</span> char <span class="ch">'-'</span>)</a>
<a class="sourceLine" id="cb7-14" title="14">         <span class="fu">&lt;*&gt;</span> (number <span class="fu">&lt;*</span> char <span class="ch">'-'</span>)</a>
<a class="sourceLine" id="cb7-15" title="15">         <span class="fu">&lt;*&gt;</span> (number)</a></code></pre></div>
<p>Remember what I said about arcane? Well, applicative style is also a bit strange. The main characteristic is the use of <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code>: if you want to parse a <code>a</code>, a <code>b</code>, and a <code>c</code> and pass the results to a function <code>f</code>, you can express this with <code>f &lt;$&gt; a &lt;*&gt; b &lt;*&gt; c</code>. This is equivalent to the following monadic code (it’s a generalization of <code>liftM</code>):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">do</span></a>
<a class="sourceLine" id="cb8-2" title="2">    ra <span class="ot">&lt;-</span> a</a>
<a class="sourceLine" id="cb8-3" title="3">    rb <span class="ot">&lt;-</span> b</a>
<a class="sourceLine" id="cb8-4" title="4">    rc <span class="ot">&lt;-</span> c</a>
<a class="sourceLine" id="cb8-5" title="5">    <span class="fu">return</span> <span class="fu">$</span> f a b c</a></code></pre></div>
<p>The other trick is the use of <code>&lt;*</code>. It parses both of its arguments, but returns only the left one. So, it is a way to parse the dash without returning it.</p>
<p>End of line is tricky here because the data is dos-formatted. Plain <code>newline</code> does not work, we have to detect <code>'\r'</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">eol ::</span> <span class="dt">Parser</span> ()</a>
<a class="sourceLine" id="cb9-2" title="2">eol <span class="fu">=</span> void <span class="fu">$</span> string <span class="st">&quot;\r\n&quot;</span></a></code></pre></div>
<p>Some parsers don’t return anything. For example, the <code>emptyLine</code> just consumes an empty line and only returns a unit value.</p>
<p>Parsing the body is just a matter of reading lines and joining them.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">body ::</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb10-2" title="2">body <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-3" title="3">    <span class="fu">unlines</span> <span class="fu">&lt;$&gt;</span> many1 line</a></code></pre></div>
<p>And a <code>line</code> is a sequence of characters that are not a new line.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">line ::</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb11-2" title="2">line <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-3" title="3">    notFollowedBy date <span class="fu">*&gt;</span> (many <span class="fu">$</span> noneOf <span class="st">&quot;\r\n&quot;</span>) <span class="fu">&lt;*</span> eol</a></code></pre></div>
<p>There are several tricks here. First, <code>*&gt;</code> and <code>&lt;*</code> make it possible to ignore the results of <code>notFollowedBy</code> and <code>eol</code>. And TODO notFollowedBy</p>
<p>We can try this using a define a function that will run the parser on <code>stdin</code> and print the result.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="ot">parseStdinOrFail ::</span> <span class="dt">IO</span> [<span class="dt">Entry</span>]</a>
<a class="sourceLine" id="cb12-2" title="2">parseStdinOrFail <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-3" title="3">    c <span class="ot">&lt;-</span> <span class="fu">getContents</span></a>
<a class="sourceLine" id="cb12-4" title="4">    <span class="kw">case</span> parse entries <span class="st">&quot;(stdin)&quot;</span> c <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-5" title="5">        <span class="dt">Left</span> e <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="fu">$</span> <span class="st">&quot;Error parsing input: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> e</a>
<a class="sourceLine" id="cb12-6" title="6">        <span class="dt">Right</span> r <span class="ot">-&gt;</span> <span class="fu">return</span> r</a>
<a class="sourceLine" id="cb12-7" title="7"></a>
<a class="sourceLine" id="cb12-8" title="8"><span class="ot">parseAndPrintStdin ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb12-9" title="9">parseAndPrintStdin <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-10" title="10">    es <span class="ot">&lt;-</span> parseStdinOrFail</a>
<a class="sourceLine" id="cb12-11" title="11">    <span class="fu">mapM_</span> <span class="fu">print</span> es</a></code></pre></div>
<h2 id="printing">Printing</h2>
<p>Here comes the second part: emitting a <code>.org</code> file that contains this data. For the rest of my journal, I will be adding entries to a date tree. This is a org-mode structure that looks like the following:</p>
<pre><code>* 2014
** 2014-10
*** 2014-10-19
**** Entry
XXXX
*** 2014-10-20
**** Entry
YYYY</code></pre>
<p>The tricky part will of course be to emit the headers at the correct position. Several approaches are possible: filling an intermediate data structure is of course an option, but as the list is already sorted it’s possible to just keep track of the current month and year.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="ot">emitEntries ::</span> [<span class="dt">Entry</span>] <span class="ot">-&gt;</span> <span class="dt">M</span> ()</a>
<a class="sourceLine" id="cb14-2" title="2">emitEntries <span class="fu">=</span></a>
<a class="sourceLine" id="cb14-3" title="3">    <span class="fu">mapM_</span> emitEntry</a></code></pre></div>
<p>Here <code>M</code> is a monad we’ll be using to keep track of the different effects. We need the followning capabilities:</p>
<ul>
<li>remember the last month and year that have been emitted</li>
<li>write lines</li>
</ul>
<p>So, a variant of RWS (Read, Write, State) will work. We don’t need the Read part, so it can be <code>()</code>; the Write part is a list of Strings; and the State part is a record containing a year and a month.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">type</span> <span class="dt">M</span> a <span class="fu">=</span> <span class="dt">RWS</span> () [<span class="dt">String</span>] <span class="dt">EmitState</span> a</a>
<a class="sourceLine" id="cb15-2" title="2"></a>
<a class="sourceLine" id="cb15-3" title="3"><span class="kw">data</span> <span class="dt">EmitState</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-4" title="4">    <span class="dt">EmitState</span> {<span class="ot"> esYear ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb15-5" title="5">              ,<span class="ot"> esMonth ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb15-6" title="6">              }</a></code></pre></div>
<p>Using this we can write the code to emit an entry:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">emitEntry ::</span> <span class="dt">Entry</span> <span class="ot">-&gt;</span> <span class="dt">M</span> ()</a>
<a class="sourceLine" id="cb16-2" title="2">emitEntry e <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="dt">EmitState</span> lastYear lastMonth <span class="ot">&lt;-</span> get</a>
<a class="sourceLine" id="cb16-4" title="4">    <span class="kw">let</span> <span class="dt">Date</span> year month day <span class="fu">=</span> entryDate e</a>
<a class="sourceLine" id="cb16-5" title="5">    when (year <span class="fu">&gt;</span> lastYear) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-6" title="6">        tell [<span class="st">&quot;* &quot;</span> <span class="fu">++</span> year]</a>
<a class="sourceLine" id="cb16-7" title="7">        modify <span class="fu">$</span> \ s <span class="ot">-&gt;</span> s { esYear <span class="fu">=</span> year }</a>
<a class="sourceLine" id="cb16-8" title="8">    when ((year, month) <span class="fu">&gt;</span> (lastYear, lastMonth)) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-9" title="9">        tell [<span class="st">&quot;** &quot;</span> <span class="fu">++</span> year <span class="fu">++</span> <span class="st">&quot;-&quot;</span> <span class="fu">++</span> month]</a>
<a class="sourceLine" id="cb16-10" title="10">        modify <span class="fu">$</span> \ s <span class="ot">-&gt;</span> s { esYear <span class="fu">=</span> year }</a>
<a class="sourceLine" id="cb16-11" title="11">        modify <span class="fu">$</span> \ s <span class="ot">-&gt;</span> s { esMonth <span class="fu">=</span> month }</a>
<a class="sourceLine" id="cb16-12" title="12">    tell [ <span class="st">&quot;*** &quot;</span> <span class="fu">++</span> year <span class="fu">++</span> <span class="st">&quot;-&quot;</span> <span class="fu">++</span> month <span class="fu">++</span> <span class="st">&quot;-&quot;</span> <span class="fu">++</span> day</a>
<a class="sourceLine" id="cb16-13" title="13">         , <span class="st">&quot;**** Entry&quot;</span></a>
<a class="sourceLine" id="cb16-14" title="14">         , entryBody e</a>
<a class="sourceLine" id="cb16-15" title="15">         ]</a></code></pre></div>
<h2 id="gluing-it-together">Gluing it together</h2>
<p>And finally our main function. To set the initial state, we use the fact that the empty string is “less” than other strings, so the first test will always write a year entry (same for the month entry).</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb17-2" title="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-3" title="3">    es <span class="ot">&lt;-</span> parseStdinOrFail</a>
<a class="sourceLine" id="cb17-4" title="4">    <span class="kw">let</span> initState <span class="fu">=</span> <span class="dt">EmitState</span> <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb17-5" title="5">        ((), _, w) <span class="fu">=</span> runRWS (emitEntries es) () initState</a>
<a class="sourceLine" id="cb17-6" title="6">    <span class="fu">mapM_</span> <span class="fu">putStrLn</span> w</a></code></pre></div>



          </div>
        </div>
        <div class="footer container">
            <p>
                I love feedback! Feel free to catch me on twitter
                (<a href="https://twitter.com/etiennemillon">@etiennemillon</a>)
                or drop me mail (me AT emillon DOT org).
            </p>
        </div>
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-51676253-1', 'emillon.org');
          ga('send', 'pageview');

        </script>
    </body>
</html>
