---
title: Parsing Brogue seed data with Parsec
author: Etienne Millon
tags: haskell parsec brogue 
---

### Gaming

When I was younger, I enjoyed a lot japanese RPGs on the SNES. Stories
were nice, combat systems were nice, these games were AA.

But now, don't enjoy too much stuff with too much theme in it. For
example, I prefer games like [Puerto Rico][BGGPuertoRico] to
[The Werewolves of Miller's Hollow][BGGWerewolves]. Of course, it's a
very different kind of game but what I like about Puerto Rico is that
like many European games, the theme is completely optional. It could
take place in Alaska, the Balkans, or ancient China and still be the
same game. What's important is that you

### Roguelikes & Brogue

Roguelikes are a type of game which are a descendant of the venerable
[Rogue][WPRogue]. The most notorious is probably [NetHack]. [Brogue], which I'll
talk about here, is a more modern roguelike, which is certainly easier for
beginners. It looks like… that:

![BrogueAnim]

As it's quite abstract, this screenshot can be read as this:

  - `@` is the player. You control its position using the hjkl keys to move it
    like in vi, and using yubn to move it diagonals.
  - `#` are walls.
  - `.` is an empty spot (you can walk over it).
  - `"` is grass. It's like an empty spot, except that it can burn.
  - `~` is water. As you can see, it's animated and beautiful (sort of).
  - `r` is a rat. There are a lot of different enemies in Brogue, with different
    characteristics. Rats are the weakest type, and are usually defeated in a
    hit.
  - `Ω` is the dungeon's exit. The goal of the game is to exit the dungeon,
    which is challenging because to unlock the exit door, you have to be in
    possession of the Amulet of Yendor which is on level 26. That is to say, you
    have to make your way through 26 levels full of enemies down and back up
    (the ascension is quite easy, though).

### Seeds & builds

In Brogue, you can't do much besides taking items, fighting monsters, and
exploring the dungeon. Much of your actions are based on the items you will
find, and they are randomly spawned.

The random system is quite ingenious. The world is statically generated by a RNG
and is entirely determined by a seed. For example, when you start a game, it's
seeded with the current time. During the gameplay, everything is deterministic
with respect to this seed.

It makes it possible to do a very simple for saved games. You just have to store
the seed and the sequence of inputs, and replay them at load time. This means
that short games are very fast to load, but end-game saves are a bit long
(~1 min).

During a game, you have to use what you find to survive. But some items can work
together to create a good "build".

For example, I was interested in trying *the jellymaster build*. It relies on a
type of enemy, the Pink Jelly, which duplicates itself when hit (although with
half health). Such an enemy could become a powerful ally, because it's a source
of unlimited allies!

To put this strategy in action, two items are needed:

  - a *wand of domination*, which converts an enemy to an ally.
  - a *staff of healing*, with which you can heal allies.

Then, the strategy is to find a pink jelly (they are common enemies), dominate
it with the wand, and heal one of the parts once in a while when it is hit.

The goal of this article is to write a tool to find seeds that have both a wand
of domination and a staff of healing accessible in the first few levels.

### Input file

Our work is greatly reduced because Brogue comes with a seed catalog, a text
file which associates seed numbers with a list of items (and the level at which
each can be found). This catalaog has been created with a modified version of
Brogue. We could modify it to allow for filtering, but postprocessing is just as
fun (and presumably more efficient).

The source file looks like a sequence of sections like:

~~~~
Seed 5:
    Depth 1:
        A scroll of remove curse
        A scroll of shattering
        A potion of descent
        A scroll of aggravate monsters
        A +2 protection charm (ready)
        A scroll of enchanting
        A potion of darkness
    Depth 2:
        121 gold pieces
        A potion of levitation
        A potion of strength
        A potion of detect magic
        A potion of creeping death
        A potion of life
        A potion of strength
        A +2 ring of clairvoyance (vault 1)
        A +1 invisibility charm (ready) (vault 1)
        A +1 ring of stealth (vault 1)
        +3 leather armor of multiplicity [6]<10> (vault 1)
        +1 banded mail of absorption [8]<15> (vault 1)
        A wand of negation [6] (vault 1)
        A wand of empowerment [1] (vault 1)
        A door key (vault 3)
    Depth 3:
        116 gold pieces
        128 gold pieces
        A +0 axe <15>
        A scroll of enchanting
        A +2 ring of regeneration
        A potion of confusion
        Some food
    Depth 4:
        149 gold pieces
        127 gold pieces
        146 gold pieces
        A potion of hallucination
        A potion of paralysis
        A potion of incineration
        A scroll of teleportation
        A +1 ring of transference (vault 3)
        A +2 ring of transference (vault 3)
        A +1 ring of transference (vault 3)
        A door key (vault 5)
        A staff of obstruction [2/2] (vault 1)
        A staff of lightning [3/3] (vault 1)
        A staff of obstruction [3/3] (vault 1)
        A staff of lightning [2/2] (vault 1)
        A staff of haste [2/2] (vault 1)
    Depth 5:
        117 gold pieces
        150 gold pieces
        A scroll of protect weapon
        A potion of incineration
        A potion of paralysis
        A +0 dagger <10>
        A scroll of identify
~~~~

To parse it, there are several options:

  - yolostyle: do something with bare hands, track indentation and handle line
    by line with perl
  - use a parser generator: write a LR grammar and use a tool such as yacc
  - use a parser combinator library. This is how we'll do and what I'll explain
    here.

Parser generators have several drawbacks. First, they require to use a separate
tool to generate code. Also, they tend to be quite slow. Finally, they are
somewhat arcane to debug (change an innocuous rule, gain 30 shift/reduce
conflicts).

On the contrary, parser combinators are nice because they are written within the
same implementation language as the rest of your code. They're just functions.
Suppose that a language has string litterals and integer litterals, and that
both are constants. To define the rule for constants, you'll just declare

~~~~ {.haskell}
constant = string_lit <|> integer_lit
~~~~

It's very declarative. `(<|>)` takes two parsers and returns a new parser which
can parse either.

[BGGPuertoRico]: http://boardgamegeek.com/boardgame/3076/puerto-rico
[BGGWerewolves]: http://boardgamegeek.com/boardgame/25821/the-werewolves-of-millers-hollow
[WPRogue]: http://en.wikipedia.org/wiki/Rogue_(video_game)
[NetHack]: http://www.nethack.org/
[Brogue]: https://sites.google.com/site/broguegame/
[BrogueAnim]: brogueanim.gif
