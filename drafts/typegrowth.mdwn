---
title: Making type inference explode
author: Etienne Millon
tags: ocaml, types
---

Hindley-Milner type systems are in a sweet spot in that they are both
expressive and easy to infer.

For example, type inference can turn this program:

~~~~ {.ocaml}
let rec length = function
  | [] -> 0 
  | x::xs -> 1 + length xs
~~~~

into this one [^1]:

[^1]:
Most of the time the only interesting part is the top-level type (`'a list ->
int`), but it is good to know that the compiler infers the type of every node.

~~~~ {.ocaml}
let rec length : 'a list -> int = function
  | [] -> (0 : int)
  | (x:'a)::(xs : 'a list) -> (1 : int)
        + ((length : 'a list -> int) (xs : 'a list) : int)
~~~~

Because the compiler does so much work, it is reasonable to wonder whether it is
efficient. The theoretical answer to this question is that type inference is
EXP-complete, but given reasonable constraints on the program (such as
annotating top-level declarations), it can be done in quasi-linear time
($n~\log~n$ where $n$ is the size of the program).

Still, one may wonder what kind of pathological cases show this exponential
effect. Here is one such example:

~~~~ {.ocaml}
let p x y = fun z -> z x y ;;

let r () =
let x1 = fun x -> p x x in
let x2 = fun z -> x1 (x1 z) in
let x3 = fun z -> x2 (x2 z) in
x3 (fun z -> z);;
~~~~

The type signature of `r` is already daunting:

~~~~
% ocamlc -i types.ml
val p : 'a -> 'b -> ('a -> 'b -> 'c) -> 'c
val r :
  unit ->
  (((((((('a -> 'a) -> ('a -> 'a) -> 'b) -> 'b) ->
       ((('a -> 'a) -> ('a -> 'a) -> 'b) -> 'b) -> 'c) ->
      'c) ->
     ((((('a -> 'a) -> ('a -> 'a) -> 'b) -> 'b) ->
       ((('a -> 'a) -> ('a -> 'a) -> 'b) -> 'b) -> 'c) ->
      'c) ->
     'd) ->
    'd) ->
   ((((((('a -> 'a) -> ('a -> 'a) -> 'b) -> 'b) ->
       ((('a -> 'a) -> ('a -> 'a) -> 'b) -> 'b) -> 'c) ->
      'c) ->
     ((((('a -> 'a) -> ('a -> 'a) -> 'b) -> 'b) ->
       ((('a -> 'a) -> ('a -> 'a) -> 'b) -> 'b) -> 'c) ->
      'c) ->
     'd) ->
    'd) ->
   'e) ->
  'e
~~~~

But what's interesting about this program is that we can add (or remove) lines
to study how input size can alter the processing time and output type size. We
can see an interesting explosion:

n   wc -c   time
- -------  -----
1      98   15ms
2     167   15ms
3     610   15ms
4   11630   38ms
5 4276270   6.3s

The reason for that can be seen if we compare two early iterations (output
simplified for clarity):

~~~~ {.ocaml}
(* n=1 *) unit->((a->a)                  ->(a->a)                  ->b)->b
(* n=2 *) unit->((((d->d)->(d->d)->e)->e)->(((d->d)->(d->d)->e)->e)->b)->b
~~~~

We can interpret this as a rewriting rule: each `'a -> 'a` is turned into `(('a
-> 'a) -> ('a -> 'a) -> 'b) -> 'b`, recursively. By counting the number of
occurrences of the leaf pattern `'a -> 'a` using `grep -c`, we can see that each
step transforms $x$ into $2x^2$.

n  leaves(n)
- ----------
1    1
2    2
3    8
4    128
5    32768
