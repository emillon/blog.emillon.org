<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Enter the void *</title>
        <link>http://blog.emillon.org</link>
        <description><![CDATA[Yet another random hacker]]></description>
        <atom:link href="http://blog.emillon.org/feeds/types.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Wed, 21 May 2014 00:00:00 UT</lastBuildDate>
        <item>
    <title>Making type inference explode</title>
    <link>http://blog.emillon.org/posts/2014-05-21-making-type-inference-explode.html</link>
    <description><![CDATA[<p>Hindley-Milner type systems are in a sweet spot in that they are both expressive and easy to infer. For example, type inference can turn this program:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">let</span> <span class="kw">rec</span> length = <span class="kw">function</span></a>
<a class="sourceLine" id="cb1-2" title="2">  | [] -&gt; <span class="dv">0</span> </a>
<a class="sourceLine" id="cb1-3" title="3">  | x::xs -&gt; <span class="dv">1</span> + length xs</a></code></pre></div>
<p>into this one (the top-level type <code>'a list -&gt; int</code> is usually what is interesting but the compiler has to infer the type of every subexpression):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">let</span> <span class="kw">rec</span> length : &#39;a <span class="dt">list</span> -&gt; <span class="dt">int</span> = <span class="kw">function</span></a>
<a class="sourceLine" id="cb2-2" title="2">  | [] -&gt; (<span class="dv">0</span> : <span class="dt">int</span>)</a>
<a class="sourceLine" id="cb2-3" title="3">  | (x:&#39;a)::(xs : &#39;a <span class="dt">list</span>) -&gt; (<span class="dv">1</span> : <span class="dt">int</span>)</a>
<a class="sourceLine" id="cb2-4" title="4">        + ((length : &#39;a <span class="dt">list</span> -&gt; <span class="dt">int</span>) (xs : &#39;a <span class="dt">list</span>) : <span class="dt">int</span>)</a></code></pre></div>
<p>Because the compiler does so much work, it is reasonable to wonder whether it is efficient. The theoretical answer to this question is that type inference is EXP-complete, but given reasonable constraints on the program, it can be done in quasi-linear time (<span class="math inline"><em>n</em> log  <em>n</em></span> where <span class="math inline"><em>n</em></span> is the size of the program).</p>
<p>Still, one may wonder what kind of pathological cases show this exponential effect. Here is one such example:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">let</span> p x y = <span class="kw">fun</span> z -&gt; z x y ;;</a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">let</span> r () =</a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">let</span> x1 = <span class="kw">fun</span> x -&gt; p x x <span class="kw">in</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">let</span> x2 = <span class="kw">fun</span> z -&gt; x1 (x1 z) <span class="kw">in</span></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="kw">let</span> x3 = <span class="kw">fun</span> z -&gt; x2 (x2 z) <span class="kw">in</span></a>
<a class="sourceLine" id="cb3-7" title="7">x3 (<span class="kw">fun</span> z -&gt; z);;</a></code></pre></div>
<p>The type signature of <code>r</code> is already daunting:</p>
<pre><code>% ocamlc -i types.ml
val p : &#39;a -&gt; &#39;b -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;c) -&gt; &#39;c
val r :
  unit -&gt;
  ((((((((&#39;a -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;a) -&gt; &#39;b) -&gt; &#39;b) -&gt;
       (((&#39;a -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;a) -&gt; &#39;b) -&gt; &#39;b) -&gt; &#39;c) -&gt;
      &#39;c) -&gt;
     (((((&#39;a -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;a) -&gt; &#39;b) -&gt; &#39;b) -&gt;
       (((&#39;a -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;a) -&gt; &#39;b) -&gt; &#39;b) -&gt; &#39;c) -&gt;
      &#39;c) -&gt;
     &#39;d) -&gt;
    &#39;d) -&gt;
   (((((((&#39;a -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;a) -&gt; &#39;b) -&gt; &#39;b) -&gt;
       (((&#39;a -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;a) -&gt; &#39;b) -&gt; &#39;b) -&gt; &#39;c) -&gt;
      &#39;c) -&gt;
     (((((&#39;a -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;a) -&gt; &#39;b) -&gt; &#39;b) -&gt;
       (((&#39;a -&gt; &#39;a) -&gt; (&#39;a -&gt; &#39;a) -&gt; &#39;b) -&gt; &#39;b) -&gt; &#39;c) -&gt;
      &#39;c) -&gt;
     &#39;d) -&gt;
    &#39;d) -&gt;
   &#39;e) -&gt;
  &#39;e</code></pre>
<p>But what’s interesting about this program is that we can add (or remove) lines to study how input size can alter the processing time and output type size. It explodes:</p>
<table>
<thead>
<tr class="header">
<th>n</th>
<th style="text-align: right;">wc -c</th>
<th style="text-align: right;">time</th>
<th style="text-align: right;">leaves(n)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td style="text-align: right;">98</td>
<td style="text-align: right;">15ms</td>
<td style="text-align: right;">1</td>
</tr>
<tr class="even">
<td>2</td>
<td style="text-align: right;">167</td>
<td style="text-align: right;">15ms</td>
<td style="text-align: right;">2</td>
</tr>
<tr class="odd">
<td>3</td>
<td style="text-align: right;">610</td>
<td style="text-align: right;">15ms</td>
<td style="text-align: right;">8</td>
</tr>
<tr class="even">
<td>4</td>
<td style="text-align: right;">11630</td>
<td style="text-align: right;">38ms</td>
<td style="text-align: right;">128</td>
</tr>
<tr class="odd">
<td>5</td>
<td style="text-align: right;">4276270</td>
<td style="text-align: right;">6.3s</td>
<td style="text-align: right;">32768</td>
</tr>
</tbody>
</table>
<p>Observing the number of <code>('a -&gt; 'a)</code> leaves in the output type reveals that it is is squared and doubled at each step, leading to an exponential growth.</p>
<p>In practice, this effect does not appear in day-to-day programs because programmers annotate the top-level declarations with their types. In that case, the size of the types would be merely proportional to the size of the program, because the type annotation would be gigantic.</p>
<p>Also, programmers tend to write functions that do something useful, which these do not seem to do ☺.</p>]]></description>
    <pubDate>Wed, 21 May 2014 00:00:00 UT</pubDate>
    <guid>http://blog.emillon.org/posts/2014-05-21-making-type-inference-explode.html</guid>
    <dc:creator>Etienne Millon</dc:creator>
</item>

    </channel>
</rss>
