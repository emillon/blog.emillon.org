<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Enter the void *</title>
        <link>http://blog.emillon.org</link>
        <description><![CDATA[Yet another random hacker]]></description>
        <atom:link href="http://blog.emillon.org/feeds/haskell.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Mon, 21 Nov 2011 00:00:00 UT</lastBuildDate>
        <item>
    <title>Hakyll 101</title>
    <link>http://blog.emillon.org/posts/2011-11-21-hakyll-101.html</link>
    <description><![CDATA[<p>So, the recent trend seems to be static blogging. Indeed, as a web application, a blog is mostly read-only. By generating static <code>.html</code> files, one can eliminate :</p>
<ul>
<li>CPU load : static content is what’s easiest to serve, especially with modern servers using <a href="http://manpages.debian.org/cgi-bin/man.cgi?query=sendfile&amp;sektion=2&amp;apropos=0&amp;manpath=Debian%206.0%20squeeze">sendfile(2)</a>.</li>
<li>security issues : without dynamic page generation, the attack surface is also vastly reduced. Authentication is moved from a PHP or Python script to the Unix way.</li>
<li>deployment problems : I don’t know a free host that won’t serve static files. I use <a href="http://aws.amazon.com/s3/">S3</a> (and the free tier will often be enough !) but if I am not satisfied, it’s dead simple to migrate.</li>
</ul>
<p>Basically, it’s like moving from a dynamic language to a static one ☺. The only problem is if you want to add comments. The popular solution is <a href="https://disqus.com">Disqus</a> but it is unfortunately a non-free application. I’ll probably stick to it but I fear data lock-in.</p>
<p>As it is fashionable, a <em>lot</em> of tools have appeared : <a href="https://github.com/ametaireau/pelican/">pelican</a>, <a href="http://blogofile.com/">blogofile</a>, <a href="http://ikiwiki.info/">ikiwiki</a>, <a href="http://jekyllrb.com/">jekyll</a>… Being a haskeller, I decided to give <a href="http://jaspervdj.be/hakyll/">hakyll</a> a try.</p>
<p>Hakyll is a haskell library for writing and deploying static websites ; that’s about it. As in a dynamic application, you define routes and how to serve them :</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">makeCss ::</span> <span class="dt">Rules</span></a>
<a class="sourceLine" id="cb1-2" title="2">makeCss <span class="fu">=</span></a>
<a class="sourceLine" id="cb1-3" title="3">  void <span class="fu">$</span> match <span class="st">&quot;css/*&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-4" title="4">      route   idRoute</a>
<a class="sourceLine" id="cb1-5" title="5">      compile compressCssCompiler</a></code></pre></div>
<p>Most rules consist of compiling <a href="http://daringfireball.net/projects/markdown/">markdown</a> to HTML (with the fantastic <a href="http://johnmacfarlane.net/pandoc/">pandoc</a> library) and copying stuff around.</p>
<p>The resulting binary, when compiled, can be run to see previews, build files or even deploy the site.</p>
<pre><code> ~/www/blog [master] % ./blog
ABOUT

This is a Hakyll site generator program. You should always
run it from the project root directory.

USAGE

blog build           Generate the site
blog clean           Clean up and remove cache
blog help            Show this message
blog preview [port]  Run a server and autocompile
blog rebuild         Clean up and build again
blog server [port]   Run a local test server
blog deploy          Upload/deploy your site</code></pre>
<p>So far I’ve found it very easy to use. That’s it for this first mini-tour. Stay tuned !</p>]]></description>
    <pubDate>Mon, 21 Nov 2011 00:00:00 UT</pubDate>
    <guid>http://blog.emillon.org/posts/2011-11-21-hakyll-101.html</guid>
    <dc:creator>Etienne Millon</dc:creator>
</item>
<item>
    <title>What's in an ADT ?</title>
    <link>http://blog.emillon.org/posts/2011-12-14-what-s-in-an-adt.html</link>
    <description><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Algebraic Data Types, or ADTs for short, are a core feature of functional languages such as OCaml or Haskell. They are a handy model of closed disjoint unions and unfortunately, outside of the functional realm, they are only seldom used.</p>
<p>In this article, I will explain what ADTs are, how they are used in OCaml and what trimmed-down versions of them exist in other languages. I will use OCaml, but the big picture is about the same in Haskell.</p>
<h2 id="principles">Principles</h2>
<p>Functional languages offer a myriad of types for the programmer.</p>
<ul>
<li>some <em>base</em> types, such as <code>int</code>, <code>char</code> or <code>bool</code>.</li>
<li>functions, ie <em>arrow</em> types. A function with domain <code>a</code> and codomain <code>b</code> has type <code>a -&gt; b</code>.</li>
<li>tuples, ie <em>product</em> types. A tuple is an heterogeneous, fixed-width container type (its set-theoretic counterpart is the cartesian product) For example, <code>(2, true, 'x')</code> has type <code>int * bool * char</code>. <em>record</em> types are a (mostly) syntactic extension to give name to their fields.</li>
<li>some <em>parametric</em> types. For example, if <code>t</code> is a type, <code>t list</code> is the type of homogeneous linked list of elements having type <code>t</code>.</li>
<li>what we are talking about today, <em>algebraic</em> types (or <em>sum</em> types, or <em>variant</em> types).</li>
</ul>
<p>If product types represent the cartesian product, algebraic types represent the disjoint union. In another words, they are very adapted for a case analysis.</p>
<p>We will take the example of integer ranges. One can say that an integer range is either :</p>
<ul>
<li>the empty range</li>
<li>of the form <code>]-∞;a]</code></li>
<li>of the form <code>[a;+∞[</code></li>
<li>an interval of the form <code>[a;b]</code> (where a ≤ b)</li>
<li>the whole range (ie, ℤ)</li>
</ul>
<p>With the following properties :</p>
<ul>
<li>Disjunction : no range can be of two forms at a time.</li>
<li>Injectivity : if <code>[a;b]</code> = <code>[c;d]</code>, then <code>a</code> = <code>c</code> and <code>b</code> = <code>d</code> (and similarly for other forms).</li>
<li>Exhaustiveness : it cannot be of another form.</li>
</ul>
<h2 id="syntax-semantics">Syntax &amp; semantics</h2>
<p>This can be encoded as an ADT :</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">type</span> range =</a>
<a class="sourceLine" id="cb1-2" title="2">  | Empty</a>
<a class="sourceLine" id="cb1-3" title="3">  | HalfLeft <span class="kw">of</span> <span class="dt">int</span></a>
<a class="sourceLine" id="cb1-4" title="4">  | HalfRight <span class="kw">of</span> <span class="dt">int</span></a>
<a class="sourceLine" id="cb1-5" title="5">  | Range <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span></a>
<a class="sourceLine" id="cb1-6" title="6">  | FullRange</a></code></pre></div>
<p><code>Empty</code>, <code>HalfLeft</code>, <code>HalfRight</code>, <code>Range</code> and <code>FullRange</code> are <code>t</code>’s <em>constructors</em>. They are the only way to build a value of type <code>t</code>. For example, <code>Empty</code>, <code>HalfLeft 3</code> and <code>Range (2, 5)</code> are all values of type <code>t</code><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. They each have a specific <em>arity</em> (the number of arguments they take).</p>
<p>To <em>deconstruct</em> a value of type <code>t</code>, we have to use a powerful construct, <em>pattern matching</em>, which is about matching a value against a sequence of patterns (yes, that’s about it).</p>
<p>To illustrate this, we will write a function that computes the minimum value of such a range. Of course, this can be ±∞ too, so we have to define a type to represent the return value.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">type</span> ext_int =</a>
<a class="sourceLine" id="cb2-2" title="2">  | MinusInfinity</a>
<a class="sourceLine" id="cb2-3" title="3">  | Finite <span class="kw">of</span> <span class="dt">int</span></a>
<a class="sourceLine" id="cb2-4" title="4">  | PlusInfinity</a></code></pre></div>
<p>In a math textbook, we would write the case analysis as :</p>
<ul>
<li>min ∅ = +∞</li>
<li>min ]-∞;a] = -∞</li>
<li>min [a;+∞[ = a</li>
<li>min [a;b] = a</li>
<li>min ℤ = -∞</li>
</ul>
<p>That translates to the following (executable !) OCaml code :</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">let</span> range_min x =</a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="kw">match</span> x <span class="kw">with</span></a>
<a class="sourceLine" id="cb3-3" title="3">  | Empty -&gt; PlusInfinity</a>
<a class="sourceLine" id="cb3-4" title="4">  | HalfLeft a -&gt; MinusInfinity</a>
<a class="sourceLine" id="cb3-5" title="5">  | HalfRight a -&gt; Finite a</a>
<a class="sourceLine" id="cb3-6" title="6">  | Range (a, b) -&gt; Finite a</a>
<a class="sourceLine" id="cb3-7" title="7">  | FullRange -&gt; MinusInfinity</a></code></pre></div>
<p>In the pattern <code>HalfLeft a</code>, <code>a</code> is a variable name, so it get bounds to the argument’s value. In other words, <code>match (HalfLeft 2) with HalfLeft x -&gt; e</code> bounds <code>x</code> to 2 in <code>e</code>.</p>
<h2 id="its-functions-all-the-way-down">It’s functions all the way down</h2>
<p>Pattern matching seems magical at first, but it is only a syntactic trick. Indeed, the definition of the above type is equivalent to the following definition :</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">type</span> range</a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co">(* The following is not syntactically correct *)</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">val</span> Empty : range</a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">val</span> HalfLeft : <span class="dt">int</span> -&gt; range</a>
<a class="sourceLine" id="cb4-6" title="6"><span class="kw">val</span> HalfRight : <span class="dt">int</span> -&gt; range</a>
<a class="sourceLine" id="cb4-7" title="7"><span class="kw">val</span> Range : <span class="dt">int</span> * <span class="dt">int</span> -&gt; range</a>
<a class="sourceLine" id="cb4-8" title="8"><span class="kw">val</span> FullRange : range</a>
<a class="sourceLine" id="cb4-9" title="9"><span class="co">(* Moreover, we know that they are injective and mutually disjoint *)</span></a>
<a class="sourceLine" id="cb4-10" title="10"></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="kw">val</span> deconstruct_range :</a>
<a class="sourceLine" id="cb4-12" title="12">  (<span class="dt">unit</span> -&gt; &#39;a) -&gt;</a>
<a class="sourceLine" id="cb4-13" title="13">  (<span class="dt">int</span> -&gt; &#39;a) -&gt;</a>
<a class="sourceLine" id="cb4-14" title="14">  (<span class="dt">int</span> -&gt; &#39;a) -&gt;</a>
<a class="sourceLine" id="cb4-15" title="15">  (<span class="dt">int</span> * <span class="dt">int</span> -&gt; &#39;a) -&gt;</a>
<a class="sourceLine" id="cb4-16" title="16">  (<span class="dt">unit</span> -&gt; &#39;a) -&gt;</a>
<a class="sourceLine" id="cb4-17" title="17">  range -&gt;</a>
<a class="sourceLine" id="cb4-18" title="18">  &#39;a</a></code></pre></div>
<p><code>deconstruct_range</code> is what replaces pattern matching. It also embodies the notion of exhaustiveness, because given any value of type <code>range</code>, we can build a deconstructed value out of it.</p>
<p>Its type looks scary at first, but if we look closer, its arguments are a sequence of case-specific deconstructors<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> and the value to get “matched” against.</p>
<p>To show the equivalence, we can implement <code>deconstruct_range</code> using pattern patching and <code>range_min</code> using <code>deconstruct_range</code><a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> :</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">let</span> deconstruct_range</a>
<a class="sourceLine" id="cb5-2" title="2">      f_empty</a>
<a class="sourceLine" id="cb5-3" title="3">      f_halfleft</a>
<a class="sourceLine" id="cb5-4" title="4">      f_halfright</a>
<a class="sourceLine" id="cb5-5" title="5">      f_range</a>
<a class="sourceLine" id="cb5-6" title="6">      f_fullrange</a>
<a class="sourceLine" id="cb5-7" title="7">      x</a>
<a class="sourceLine" id="cb5-8" title="8">    =</a>
<a class="sourceLine" id="cb5-9" title="9">  <span class="kw">match</span> x <span class="kw">with</span></a>
<a class="sourceLine" id="cb5-10" title="10">  | Empty -&gt; f_empty ()</a>
<a class="sourceLine" id="cb5-11" title="11">  | HalfLeft a -&gt; f_halfleft a</a>
<a class="sourceLine" id="cb5-12" title="12">  | HalfRight a -&gt; f_halfright a</a>
<a class="sourceLine" id="cb5-13" title="13">  | Range (a, b) -&gt; f_range (a, b)</a>
<a class="sourceLine" id="cb5-14" title="14">  | FullRange -&gt; f_fullrange ()</a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">let</span> range_min&#39; x =</a>
<a class="sourceLine" id="cb6-2" title="2">  deconstruct_range</a>
<a class="sourceLine" id="cb6-3" title="3">    (<span class="kw">fun</span> () -&gt; PlusInfinity)</a>
<a class="sourceLine" id="cb6-4" title="4">    (<span class="kw">fun</span> a -&gt; MinusInfinity)</a>
<a class="sourceLine" id="cb6-5" title="5">    (<span class="kw">fun</span> a -&gt; Finite a)</a>
<a class="sourceLine" id="cb6-6" title="6">    (<span class="kw">fun</span> (a, b) -&gt; Finite a)</a>
<a class="sourceLine" id="cb6-7" title="7">    (<span class="kw">fun</span> () -&gt; MinusInfinity)</a>
<a class="sourceLine" id="cb6-8" title="8">    x</a></code></pre></div>
<h2 id="implementation">Implementation</h2>
<p>After this trip in denotational-land, let’s get back to operational-land : how is this implemented ?</p>
<p>In OCaml, no type information exists at runtime. Everything exists with a uniform representation and is either an integer or a pointer to a block. Each block starts with a tag, a size and a number of fields.</p>
<p>With the <code>Obj</code> module (kids, don’t try this at home), it is possible to inspect blocks at runtime. Let’s write a dumper for <code>range</code> value and watch outputs :</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb7-1" title="1"><span class="co">(* Range of integers between a and b *)</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">let</span> <span class="kw">rec</span> rng a b =</a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="kw">if</span> a &gt; b <span class="kw">then</span></a>
<a class="sourceLine" id="cb7-4" title="4">    []</a>
<a class="sourceLine" id="cb7-5" title="5">  <span class="kw">else</span></a>
<a class="sourceLine" id="cb7-6" title="6">    a :: rng (a+<span class="dv">1</span>) b</a>
<a class="sourceLine" id="cb7-7" title="7"></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="kw">let</span> view_block o =</a>
<a class="sourceLine" id="cb7-9" title="9">  <span class="kw">if</span> (Obj.is_block o) <span class="kw">then</span></a>
<a class="sourceLine" id="cb7-10" title="10">    <span class="kw">begin</span></a>
<a class="sourceLine" id="cb7-11" title="11">      <span class="kw">let</span> tag = Obj.tag o <span class="kw">in</span></a>
<a class="sourceLine" id="cb7-12" title="12">      <span class="kw">let</span> sz = Obj.size o <span class="kw">in</span></a>
<a class="sourceLine" id="cb7-13" title="13">      <span class="kw">let</span> f n =</a>
<a class="sourceLine" id="cb7-14" title="14">        <span class="kw">let</span> f = Obj.field o n <span class="kw">in</span></a>
<a class="sourceLine" id="cb7-15" title="15">        <span class="kw">assert</span> (Obj.is_int f);</a>
<a class="sourceLine" id="cb7-16" title="16">        Obj.obj f</a>
<a class="sourceLine" id="cb7-17" title="17">      <span class="kw">in</span></a>
<a class="sourceLine" id="cb7-18" title="18">      tag :: <span class="dt">List</span>.map f (rng <span class="dv">0</span> (sz<span class="dv">-1</span>))</a>
<a class="sourceLine" id="cb7-19" title="19">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb7-20" title="20">  <span class="kw">else</span> <span class="kw">if</span> Obj.is_int o <span class="kw">then</span></a>
<a class="sourceLine" id="cb7-21" title="21">    [Obj.obj o]</a>
<a class="sourceLine" id="cb7-22" title="22">  <span class="kw">else</span></a>
<a class="sourceLine" id="cb7-23" title="23">    <span class="kw">assert</span> <span class="kw">false</span></a>
<a class="sourceLine" id="cb7-24" title="24"></a>
<a class="sourceLine" id="cb7-25" title="25"><span class="kw">let</span> examples () =</a>
<a class="sourceLine" id="cb7-26" title="26">  <span class="kw">let</span> p_list l =</a>
<a class="sourceLine" id="cb7-27" title="27">    <span class="dt">String</span>.concat <span class="st">&quot;;&quot;</span> (<span class="dt">List</span>.map <span class="dt">string_of_int</span> l)</a>
<a class="sourceLine" id="cb7-28" title="28">  <span class="kw">in</span></a>
<a class="sourceLine" id="cb7-29" title="29">  <span class="kw">let</span> explore_range r =</a>
<a class="sourceLine" id="cb7-30" title="30">    <span class="dt">print_endline</span> (p_list (view_block (Obj.repr r)))</a>
<a class="sourceLine" id="cb7-31" title="31">  <span class="kw">in</span></a>
<a class="sourceLine" id="cb7-32" title="32">  <span class="dt">List</span>.iter explore_range</a>
<a class="sourceLine" id="cb7-33" title="33">    [ Empty</a>
<a class="sourceLine" id="cb7-34" title="34">    ; HalfLeft <span class="dv">8</span></a>
<a class="sourceLine" id="cb7-35" title="35">    ; HalfRight <span class="dv">13</span></a>
<a class="sourceLine" id="cb7-36" title="36">    ; Range (<span class="dv">2</span>, <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb7-37" title="37">    ; FullRange</a>
<a class="sourceLine" id="cb7-38" title="38">    ]</a></code></pre></div>
<p>When we run <code>examples ()</code>, it outputs :</p>
<pre><code>0
0;8
1;13
2;2;5
1</code></pre>
<p>We can see the following distinction :</p>
<ul>
<li>0-ary constructors (<code>Empty</code> and <code>FullRange</code>) are encoded are simple integers.</li>
<li>other ones are encoded blocks with a constructor number as tag (0 for <code>HalfLeft</code>, 1 for <code>HalfRight</code> and 2 for <code>Range</code>) and their argument list afterwards.</li>
</ul>
<p>Thanks to this uniform representation, pattern-matching is straightforward : the runtime system will only look at the tag number to decide which constructor has been used, and if there are arguments to be bound, they are just after in the same block.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Algebraic Data Types are a simple model of disjoint unions, for which case analyses are the most natural. In more mainstream languages, some alternatives exist but they are more limited to model the same problem.</p>
<p>For example, in object-oriented languages, the Visitor pattern is the natural way to do it. But class trees are inherently “open”, thus breaking the exhaustivity property.</p>
<p>The closest implementation is tagged unions in C, but they require to roll your own solution using <code>enum</code>s, <code>struct</code>s and <code>union</code>s. This also means that all your hand-allocated blocks will have the same size.</p>
<p>Oh, and I would love to know how this problem is solved with other paradigms !</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Unfortunately, so is <code>Range (10, 2)</code>. The invariant that a ≤ b has to be enforced by the programmer when using this constructor.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>For 0-ary constructors, the type has to be <code>unit -&gt; 'a</code> instead of <code>'a</code> to allow side effects to happen during pattern matching.<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>More precisely, we would have to show that any function written with pattern matching can be adapted to use the deconstructor instead. I hope that this example is general enough to get the idea.<a href="#fnref3" class="footnote-back">↩</a></p></li>
</ol>
</section>]]></description>
    <pubDate>Wed, 14 Dec 2011 00:00:00 UT</pubDate>
    <guid>http://blog.emillon.org/posts/2011-12-14-what-s-in-an-adt.html</guid>
    <dc:creator>Etienne Millon</dc:creator>
</item>
<item>
    <title>Comonadic Life</title>
    <link>http://blog.emillon.org/posts/2012-10-18-comonadic-life.html</link>
    <description><![CDATA[<h2 id="of-monads-and-comonads">Of monads and comonads</h2>
<p>This post is written in <a href="http://www.haskell.org/haskellwiki/Literate_programming">Literate Haskell</a>. This means that you can copy it into a <code>.lhs</code> file<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> and run it through a Haskell compiler or interpreter.</p>
<p>Today we’ll talk about…</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">import</span> <span class="dt">Control.Comonad</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">import</span> <span class="dt">Control.Monad</span></a></code></pre></div>
<p>Comonads ! They are the categoric dual of monads, which means that the type signatures of comonadic functions look like monadic functions, but with the arrow reversed. I am not an expert in category theory, so I won’t go further.</p>
<p>I will use the following typeclass for comonads : it’s from <a href="http://comonad.com">Edward Kmett</a>’s <a href="http://hackage.haskell.org/package/comonad-3.0.0.2/docs/Control-Comonad.html">comonad package</a> (split from the infamous <a href="http://hackage.haskell.org/package/category-extras-1.0.2">category-extras package</a>).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">class</span> <span class="dt">Functor</span> w <span class="ot">=&gt;</span> <span class="dt">Comonad</span> w <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="ot">  extract ::</span> w a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="ot">  extend ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="ot">  duplicate ::</span> w a <span class="ot">-&gt;</span> w (w a)</a></code></pre></div>
<p><code>extend</code> or <code>duplicate</code> are optional, as one can be written in terms of the other one. The Monad typeclass, for reference, can be described as<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> :</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">class</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="ot">  (=&lt;&lt;) ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b</a>
<a class="sourceLine" id="cb3-4" title="4"><span class="ot">  join ::</span> m (m a) <span class="ot">-&gt;</span> m a</a></code></pre></div>
<p>The duality is quite easy to see : <code>extract</code> is the dual of <code>return</code>, <code>extend</code> the one of <code>(=&lt;&lt;)</code> and <code>duplicate</code> the one of <code>join</code>.</p>
<p>So what are comonads good for ?</p>
<p>I stumbled upon <a href="http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html">an article</a> which explains that they can be used for computations which depend on some local environment, like <a href="http://en.wikipedia.org/wiki/Cellular_automaton">cellular automata</a>. Comments ask whether it’s possible to generalize to higher dimensions, which I will do by implementing <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway’s Game of Life</a> in a comonadic way.</p>
<h2 id="list-zippers">List Zippers</h2>
<p>List zippers are a fantastic data structure, allowing O(1) edits at a “cursor”. Moving the cursor element to element is O(1) too. This makes it a very nice data structure when your edits are local (say, in a text editor). You can learn more about zippers in general in this <a href="http://blog.ezyang.com/2010/04/you-could-have-invented-zippers/">post from Edward Z Yang</a>. The seminal paper is of course <a href="http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf">Huet’s article</a>.</p>
<p>A list zipper is composed of a cursor and two lists.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">data</span> <span class="dt">ListZipper</span> a <span class="fu">=</span> <span class="dt">LZ</span> [a] a [a]</a></code></pre></div>
<p>To go in a direction, you pick the head of a list, set it as your cursor, and push the cursor on top of the other list. We assume that we will only infinte lists, so this operation can not fail. This assumption is reasonnable especially in the context of cellular automata<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">listLeft ::</span> <span class="dt">ListZipper</span> a <span class="ot">-&gt;</span> <span class="dt">ListZipper</span> a</a>
<a class="sourceLine" id="cb5-2" title="2">listLeft (<span class="dt">LZ</span> (l<span class="fu">:</span>ls) x rs) <span class="fu">=</span> <span class="dt">LZ</span> ls l (x<span class="fu">:</span>rs)</a>
<a class="sourceLine" id="cb5-3" title="3">listLeft _ <span class="fu">=</span> <span class="fu">error</span> <span class="st">&quot;listLeft&quot;</span></a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="ot">listRight ::</span> <span class="dt">ListZipper</span> a <span class="ot">-&gt;</span> <span class="dt">ListZipper</span> a</a>
<a class="sourceLine" id="cb5-6" title="6">listRight (<span class="dt">LZ</span> ls x (r<span class="fu">:</span>rs)) <span class="fu">=</span> <span class="dt">LZ</span> (x<span class="fu">:</span>ls) r rs</a>
<a class="sourceLine" id="cb5-7" title="7">listRight _ <span class="fu">=</span> <span class="fu">error</span> <span class="st">&quot;listRight&quot;</span></a></code></pre></div>
<p>Reading and writing on a list zipper at the cursor is straightforward :</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">listRead ::</span> <span class="dt">ListZipper</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb6-2" title="2">listRead (<span class="dt">LZ</span> _ x _) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="ot">listWrite ::</span> a <span class="ot">-&gt;</span> <span class="dt">ListZipper</span> a <span class="ot">-&gt;</span> <span class="dt">ListZipper</span> a</a>
<a class="sourceLine" id="cb6-5" title="5">listWrite x (<span class="dt">LZ</span> ls _ rs) <span class="fu">=</span> <span class="dt">LZ</span> ls x rs</a></code></pre></div>
<p>We can also define a function to convert a list zipper to a list, for example for printing. As it’s infinite on both sizes, it’s not possible to convert it to the whole list, so we have to pass a size parameter.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">toList ::</span> <span class="dt">ListZipper</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb7-2" title="2">toList (<span class="dt">LZ</span> ls x rs) n <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="fu">reverse</span> (<span class="fu">take</span> n ls) <span class="fu">++</span> [x] <span class="fu">++</span> <span class="fu">take</span> n rs</a></code></pre></div>
<p>We can easily define a <code>Functor</code> instance for <code>ListZipper</code>. To apply a function on whole zipper, we apply it to the cursor and map it on the two lists :</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">ListZipper</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" title="2">  <span class="fu">fmap</span> f (<span class="dt">LZ</span> ls x rs) <span class="fu">=</span> <span class="dt">LZ</span> (<span class="fu">map</span> f ls) (f x) (<span class="fu">map</span> f rs)</a></code></pre></div>
<p>Time for the <code>Comonad</code> instance. The <code>extract</code> method returns an element from the structure : we can pick the one at the cursor.</p>
<p><code>duplicate</code> is a bit harder to grasp. From a list zipper, we have to build a list zipper of list zippers. The signification behind this (confirmed by the comonad laws that every instance has to fulfill) is that moving inside the duplicated structure returns the original structure, altered by the same move : for example, <code>listRead (listLeft (duplicate z)) == listLeft z</code>.</p>
<p>This means that at the cursor of the duplicated structure, there is the original structure <code>z</code>. And the left list is composed of <code>listLeft z</code>, <code>listLeft (listLeft z)</code>, <code>listLeft (listLeft (listLeft z))</code>, etc (same goes for the right list).</p>
<p>The following function applies repeatedly two movement functions on each side of the zipper (its type is more generic than needed for this specific case but we’ll instanciate <code>z</code> with something other than <code>ListZipper</code> in the next section).</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">genericMove ::</span> (z a <span class="ot">-&gt;</span> z a)</a>
<a class="sourceLine" id="cb9-2" title="2">            <span class="ot">-&gt;</span> (z a <span class="ot">-&gt;</span> z a)</a>
<a class="sourceLine" id="cb9-3" title="3">            <span class="ot">-&gt;</span> z a</a>
<a class="sourceLine" id="cb9-4" title="4">            <span class="ot">-&gt;</span> <span class="dt">ListZipper</span> (z a)</a>
<a class="sourceLine" id="cb9-5" title="5">genericMove a b z <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-6" title="6">  <span class="dt">LZ</span> (iterate&#39; a z) z (iterate&#39; b z)</a>
<a class="sourceLine" id="cb9-7" title="7"></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="ot">iterate&#39; ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb9-9" title="9">iterate&#39; f <span class="fu">=</span> <span class="fu">tail</span> <span class="fu">.</span> <span class="fu">iterate</span> f</a></code></pre></div>
<p>And finally we can implement the instance.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">instance</span> <span class="dt">Comonad</span> <span class="dt">ListZipper</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" title="2">  extract <span class="fu">=</span> listRead</a>
<a class="sourceLine" id="cb10-3" title="3"></a>
<a class="sourceLine" id="cb10-4" title="4">  duplicate <span class="fu">=</span> genericMove listLeft listRight</a></code></pre></div>
<p>Using this comonad instance we can already implement 1D cellular automata, as explained in the <a href="http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html">sigfpe article</a>. Let’s see how they can be extended to 2D automata.</p>
<h2 id="plane-zippers">Plane zippers</h2>
<p>Let’s generalize list zippers to plane zippers, which are cursors on a plane of cells. We will implement them using a list zipper of list zippers.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">data</span> <span class="dt">Z</span> a <span class="fu">=</span> <span class="dt">Z</span> (<span class="dt">ListZipper</span> (<span class="dt">ListZipper</span> a))</a></code></pre></div>
<p>We start by defining move functions. As a convention, the external list will hold lines : to move up and down, we will really move left and right at the root level.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="ot">up ::</span> <span class="dt">Z</span> a <span class="ot">-&gt;</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb12-2" title="2">up (<span class="dt">Z</span> z) <span class="fu">=</span> <span class="dt">Z</span> (listLeft z)</a>
<a class="sourceLine" id="cb12-3" title="3"></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="ot">down ::</span> <span class="dt">Z</span> a <span class="ot">-&gt;</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb12-5" title="5">down (<span class="dt">Z</span> z) <span class="fu">=</span> <span class="dt">Z</span> (listRight z)</a></code></pre></div>
<p>For left and right, it is necessary to alter every line, using the <code>Functor</code> instance.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="ot">left ::</span> <span class="dt">Z</span> a <span class="ot">-&gt;</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb13-2" title="2">left (<span class="dt">Z</span> z) <span class="fu">=</span> <span class="dt">Z</span> (<span class="fu">fmap</span> listLeft z)</a>
<a class="sourceLine" id="cb13-3" title="3"></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="ot">right ::</span> <span class="dt">Z</span> a <span class="ot">-&gt;</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb13-5" title="5">right (<span class="dt">Z</span> z) <span class="fu">=</span> <span class="dt">Z</span> (<span class="fu">fmap</span> listRight z)</a></code></pre></div>
<p>Finally, editing is quite straightforward : reading is direct (first read the line, then the cursor) ; and in order to write, it is necessary to fetch the current line, write to it and write the new line.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="ot">zRead ::</span> <span class="dt">Z</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb14-2" title="2">zRead (<span class="dt">Z</span> z) <span class="fu">=</span> listRead <span class="fu">$</span> listRead z</a>
<a class="sourceLine" id="cb14-3" title="3"></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="ot">zWrite ::</span> a <span class="ot">-&gt;</span> <span class="dt">Z</span> a <span class="ot">-&gt;</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb14-5" title="5">zWrite x (<span class="dt">Z</span> z) <span class="fu">=</span></a>
<a class="sourceLine" id="cb14-6" title="6">  <span class="dt">Z</span> <span class="fu">$</span> listWrite newLine z</a>
<a class="sourceLine" id="cb14-7" title="7">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-8" title="8">      newLine <span class="fu">=</span> listWrite x oldLine</a>
<a class="sourceLine" id="cb14-9" title="9">      oldLine <span class="fu">=</span> listRead z</a></code></pre></div>
<p>Time for algebra. Let’s define a <code>Functor</code> instance : applying a function everywhere can be achieved by applying it on every line.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="fu">fmap</span> f (<span class="dt">Z</span> z) <span class="fu">=</span> <span class="dt">Z</span> (<span class="fu">fmap</span> (<span class="fu">fmap</span> f) z)</a></code></pre></div>
<p>The idea behind the <code>Comonad</code> instance for <code>Z</code> is the same that the <code>ListZipper</code> one : moving “up” in the structure (really, “left” at the root level) returns the original structure moved in this direction.</p>
<p>We will reuse the <code>genericMove</code> defined earlier in order to build list zippers that describe movements in the two axes<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">horizontal ::</span> <span class="dt">Z</span> a <span class="ot">-&gt;</span> <span class="dt">ListZipper</span> (<span class="dt">Z</span> a)</a>
<a class="sourceLine" id="cb16-2" title="2">horizontal <span class="fu">=</span> genericMove left right</a>
<a class="sourceLine" id="cb16-3" title="3"></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="ot">vertical ::</span> <span class="dt">Z</span> a <span class="ot">-&gt;</span> <span class="dt">ListZipper</span> (<span class="dt">Z</span> a)</a>
<a class="sourceLine" id="cb16-5" title="5">vertical <span class="fu">=</span> genericMove up down</a></code></pre></div>
<p>This is enough to define the instance.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">instance</span> <span class="dt">Comonad</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-2" title="2">  extract <span class="fu">=</span> zRead</a>
<a class="sourceLine" id="cb17-3" title="3"></a>
<a class="sourceLine" id="cb17-4" title="4">  duplicate z <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-5" title="5">    <span class="dt">Z</span> <span class="fu">$</span> <span class="fu">fmap</span> horizontal <span class="fu">$</span> vertical z</a></code></pre></div>
<h2 id="conways-comonadic-game-of-life">Conway’s (comonadic) Game of Life</h2>
<p>Let’s define a neighbourhood function. Here, directions are moves on a plane zipper. Neighbours are : horizontal moves, vertical moves and their compositions (<code>liftM2 (.)</code>)<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="ot">neighbours ::</span> [<span class="dt">Z</span> a <span class="ot">-&gt;</span> <span class="dt">Z</span> a]</a>
<a class="sourceLine" id="cb18-2" title="2">neighbours <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-3" title="3">  horiz <span class="fu">++</span> vert <span class="fu">++</span> liftM2 (<span class="fu">.</span>) horiz vert</a>
<a class="sourceLine" id="cb18-4" title="4">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-5" title="5">      horiz <span class="fu">=</span> [left, right]</a>
<a class="sourceLine" id="cb18-6" title="6">      vert  <span class="fu">=</span> [up, down]</a>
<a class="sourceLine" id="cb18-7" title="7"></a>
<a class="sourceLine" id="cb18-8" title="8"><span class="ot">aliveNeighbours ::</span> <span class="dt">Z</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb18-9" title="9">aliveNeighbours z <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-10" title="10">  card <span class="fu">$</span> <span class="fu">map</span> (\ dir <span class="ot">-&gt;</span> extract <span class="fu">$</span> dir z) neighbours</a>
<a class="sourceLine" id="cb18-11" title="11"></a>
<a class="sourceLine" id="cb18-12" title="12"><span class="ot">card ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb18-13" title="13">card <span class="fu">=</span> <span class="fu">length</span> <span class="fu">.</span> <span class="fu">filter</span> (<span class="fu">==</span><span class="dt">True</span>)</a></code></pre></div>
<p>The core rule of the game fits in the following function : if two neighbours are alive, return the previous state ; if three neighbours are alive, a new cell is born, and any other count causes the cell to die (of under-population or overcrowding).</p>
<p>It is remarkable that its type is the dual of that of a Kleisli arrow (<code>a -&gt; m b</code>).</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="ot">rule ::</span> <span class="dt">Z</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb19-2" title="2">rule z <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-3" title="3">  <span class="kw">case</span> aliveNeighbours z <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-4" title="4">    <span class="dv">2</span> <span class="ot">-&gt;</span> extract z</a>
<a class="sourceLine" id="cb19-5" title="5">    <span class="dv">3</span> <span class="ot">-&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb19-6" title="6">    _ <span class="ot">-&gt;</span> <span class="dt">False</span></a></code></pre></div>
<p>And then the comonadic magic happens with the use of <code>extend</code> :</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="ot">evolve ::</span> <span class="dt">Z</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Z</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb20-2" title="2">evolve <span class="fu">=</span> extend rule</a></code></pre></div>
<p><code>evolve</code> is our main transition function between world states, and yet it’s only defined in terms of the local transition function !</p>
<p>Let’s define a small printer to see what’s going on.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="ot">dispLine ::</span> <span class="dt">ListZipper</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb21-2" title="2">dispLine z <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-3" title="3">  <span class="fu">map</span> dispC <span class="fu">$</span> toList z <span class="dv">6</span></a>
<a class="sourceLine" id="cb21-4" title="4">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-5" title="5">      dispC <span class="dt">True</span>  <span class="fu">=</span> <span class="ch">&#39;*&#39;</span></a>
<a class="sourceLine" id="cb21-6" title="6">      dispC <span class="dt">False</span> <span class="fu">=</span> <span class="ch">&#39; &#39;</span></a>
<a class="sourceLine" id="cb21-7" title="7"></a>
<a class="sourceLine" id="cb21-8" title="8"><span class="ot">disp ::</span> <span class="dt">Z</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb21-9" title="9">disp (<span class="dt">Z</span> z) <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-10" title="10">  <span class="fu">unlines</span> <span class="fu">$</span> <span class="fu">map</span> dispLine <span class="fu">$</span> toList z <span class="dv">6</span></a></code></pre></div>
<p>Here is the classic glider pattern to test. The definition has a lot of boilerplate because we did not bother to create a <code>fromList</code> function.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="ot">glider ::</span> <span class="dt">Z</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb22-2" title="2">glider <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-3" title="3">  <span class="dt">Z</span> <span class="fu">$</span> <span class="dt">LZ</span> (<span class="fu">repeat</span> fz) fz rs</a>
<a class="sourceLine" id="cb22-4" title="4">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-5" title="5">      rs <span class="fu">=</span> [ line [f, t, f]</a>
<a class="sourceLine" id="cb22-6" title="6">           , line [f, f, t]</a>
<a class="sourceLine" id="cb22-7" title="7">           , line [t, t, t]</a>
<a class="sourceLine" id="cb22-8" title="8">           ] <span class="fu">++</span> <span class="fu">repeat</span> fz</a>
<a class="sourceLine" id="cb22-9" title="9">      t <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb22-10" title="10">      f <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb22-11" title="11">      fl <span class="fu">=</span> <span class="fu">repeat</span> f</a>
<a class="sourceLine" id="cb22-12" title="12">      fz <span class="fu">=</span> <span class="dt">LZ</span> fl f fl</a>
<a class="sourceLine" id="cb22-13" title="13">      line l <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-14" title="14">        <span class="dt">LZ</span> fl f (l <span class="fu">++</span> fl)</a></code></pre></div>
<pre><code>*Main&gt; putStr $ disp glider
             
             
             
             
             
             
             
        *    
         *   
       ***   
             
             
             
*Main&gt; putStr $ disp $ evolve glider
             
             
             
             
             
             
             
             
       * *   
        **   
        *    
             
             </code></pre>
<p>We did it ! Implementing Conway’s Game of Life is usually full of ad-hoc boilerplate code : iterating loops, managing copies of cells, etc. Using the comonadic structure of cellular automata, the code can be a lot simpler.</p>
<p>In this example, <code>ListZipper</code> and <code>Z</code> should be library functions, so the actual implementation is only a dozen lines long!</p>
<p>The real benefit is that it has really helped be grasp the concept of comonads. I hope that I did not just fall into the comonad tutorial fallacy :)</p>
<p><strong>Update (March 10th):</strong> Brian Cohen contributed <a href="http://lpaste.net/83811">a simple extension to simulate a closed topology</a>. Thanks !</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Or download the <a href="https://github.com/emillon/blog.emillon.org">source on github</a>.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>In the real Haskell typeclass, there are the following differences: Monad and Functor are not related, <code>join</code> is a library function (you can’t use it to define an instance), <code>(&gt;&gt;=)</code> is used instead of its flipped counterpart <code>(=&lt;&lt;)</code> and there two more methods <code>(&gt;&gt;)</code> and <code>fail</code>.<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>Simulating a closed topology such as a torus may even be possible using cyclic lists instead of lazy infinite lists. <strong>Update:</strong> see Brian Cohen’s response at the end of this post.<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>At first I thought that it was possible to only use the <code>Comonad</code> instance of <code>ListZipper</code> to define <code>horizontal</code> and <code>vertical</code>, but I couldn’t come up with a solution. But in that case, the <code>z</code> generic parameter is instanciated to <code>Z</code>, not <code>ListZipper</code>. For that reason I believe that my initial thought can’t be implemented. Maybe it’s possible with a comonad transformer or something like that.<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>This could have been written in extension as there are only 8 cases, but it’s funnier and arguably less error prone this way :-)<a href="#fnref5" class="footnote-back">↩</a></p></li>
</ol>
</section>]]></description>
    <pubDate>Thu, 18 Oct 2012 00:00:00 UT</pubDate>
    <guid>http://blog.emillon.org/posts/2012-10-18-comonadic-life.html</guid>
    <dc:creator>Etienne Millon</dc:creator>
</item>
<item>
    <title>A lens-based ST20 emulator</title>
    <link>http://blog.emillon.org/posts/2015-08-20-a-lens-based-st20-emulator.html</link>
    <description><![CDATA[<p>Every year, as part of the <a href="https://www.sstic.org/">SSTIC conference</a>, there is a forensics/reverse engineering challenge. I participated in the 2015 edition. Though I did not manage to complete it, I made an emulator for the exotic ST20 architecture, which is probably worth describing here.</p>
<figure>
<img src="2015-08-20-a-lens-based-st20-emulator/t00f.png" alt="Some programs will loop. It’s OK." /><figcaption>Some programs will loop. It’s OK.</figcaption>
</figure>
<p>Note that this emulator is not really optimized for pure speed. In the actual challenge I actually had to rewrite it as pure Haskell (i.e., removing the emulation part) so that it was faster. Instead, the goal of this article is to show a few techniques to write powerful emulators in Haskell.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="ot">{-# LANGUAGE Rank2Types #-}</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">import</span> <span class="dt">Control.Applicative</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">import</span> <span class="dt">Control.Concurrent</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">import</span> <span class="dt">Control.Monad.RWS</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="kw">import</span> <span class="dt">Control.Lens</span> <span class="kw">hiding</span> (imap, op)</a>
<a class="sourceLine" id="cb1-8" title="8"><span class="kw">import</span> <span class="dt">Data.Bits</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">import</span> <span class="dt">Data.Int</span></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="kw">import</span> <span class="dt">Data.Maybe</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="kw">import</span> <span class="dt">Data.Word</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="kw">import</span> <span class="dt">Numeric</span></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="kw">import</span> <span class="dt">System.Exit</span></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="kw">import</span> <span class="dt">System.IO</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="kw">import</span> <span class="dt">Text.Printf</span></a>
<a class="sourceLine" id="cb1-16" title="16"></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">BS</span></a>
<a class="sourceLine" id="cb1-18" title="18"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">S</span></a></code></pre></div>
<h2 id="the-evaluation-monad">The evaluation monad</h2>
<p>This program uses Template Haskell to define lenses, so unfortunately we need to start with a few type definitions.</p>
<p>The ST20’s memory goes from <code>0x80000000</code> to <code>0x7fffffff</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">type</span> <span class="dt">Address</span> <span class="fu">=</span> <span class="dt">Int32</span></a></code></pre></div>
<p>We’ll represent the memory using a map. The performance is surprisingly close to that of an array. It is possible to get significantly speeds up memory access by using an <code>IOUArray</code> but it turns loads and stores become monadic operations and makes it impossible to use lenses.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">type</span> <span class="dt">Mem</span> <span class="fu">=</span> <span class="dt">M.Map</span> <span class="dt">Address</span> <span class="dt">Word8</span></a></code></pre></div>
<p>As we’ll see, <em>transputers</em> (hardware threads) can communicate together. We’ll be able to connect it either between them, or to a tty.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">data</span> <span class="dt">IChannel</span> <span class="fu">=</span> <span class="dt">InChan</span> (<span class="dt">Chan</span> <span class="dt">Word8</span>)</a>
<a class="sourceLine" id="cb4-2" title="2">              <span class="fu">|</span> <span class="dt">InHandle</span> <span class="dt">Handle</span></a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">data</span> <span class="dt">OChannel</span> <span class="fu">=</span> <span class="dt">OutChan</span> (<span class="dt">Chan</span> <span class="dt">Word8</span>)</a>
<a class="sourceLine" id="cb4-5" title="5">              <span class="fu">|</span> <span class="dt">OutHandle</span> <span class="dt">Handle</span></a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="kw">type</span> <span class="dt">IChannelMap</span> <span class="fu">=</span> [(<span class="dt">Int32</span>, <span class="dt">IChannel</span>)]</a>
<a class="sourceLine" id="cb4-8" title="8"><span class="kw">type</span> <span class="dt">OChannelMap</span> <span class="fu">=</span> [(<span class="dt">Int32</span>, <span class="dt">OChannel</span>)]</a></code></pre></div>
<p>All evaluations take place in a <code>Eval</code> Monad which is a monad transformer stack with the following capabilities:</p>
<ul>
<li>read and write an <code>EvalState</code> value;</li>
<li>read an <code>EvalEnv</code> value</li>
<li>do some I/O.</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">newtype</span> <span class="dt">Eval</span> a <span class="fu">=</span> <span class="dt">Eval</span> (<span class="dt">RWST</span> <span class="dt">EvalEnv</span> () <span class="dt">EvalState</span> <span class="dt">IO</span> a)</a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="kw">deriving</span> ( <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb5-3" title="3">             , <span class="dt">Monad</span></a>
<a class="sourceLine" id="cb5-4" title="4">             , <span class="dt">MonadIO</span></a>
<a class="sourceLine" id="cb5-5" title="5">             , <span class="dt">MonadReader</span> <span class="dt">EvalEnv</span></a>
<a class="sourceLine" id="cb5-6" title="6">             , <span class="dt">MonadState</span> <span class="dt">EvalState</span></a>
<a class="sourceLine" id="cb5-7" title="7">             )</a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="kw">data</span> <span class="dt">EvalEnv</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="dt">EvalEnv</span></a>
<a class="sourceLine" id="cb5-11" title="11">        {<span class="ot"> envInChans ::</span> <span class="dt">IChannelMap</span></a>
<a class="sourceLine" id="cb5-12" title="12">        ,<span class="ot"> envOutChans ::</span> <span class="dt">OChannelMap</span></a>
<a class="sourceLine" id="cb5-13" title="13">        }</a>
<a class="sourceLine" id="cb5-14" title="14"></a>
<a class="sourceLine" id="cb5-15" title="15"><span class="kw">data</span> <span class="dt">EvalState</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-16" title="16">    <span class="dt">EvalState</span></a>
<a class="sourceLine" id="cb5-17" title="17">        {<span class="ot"> _iptr ::</span> <span class="fu">!</span><span class="dt">Address</span></a>
<a class="sourceLine" id="cb5-18" title="18">        ,<span class="ot"> _intStack ::</span> [<span class="dt">Int32</span>]</a>
<a class="sourceLine" id="cb5-19" title="19">        ,<span class="ot"> _wptr ::</span> <span class="fu">!</span><span class="dt">Int32</span></a>
<a class="sourceLine" id="cb5-20" title="20">        ,<span class="ot"> _mem ::</span> <span class="fu">!</span><span class="dt">Mem</span></a>
<a class="sourceLine" id="cb5-21" title="21">        }</a>
<a class="sourceLine" id="cb5-22" title="22"><span class="fu">$</span>(makeLenses &#39;<span class="dt">&#39;EvalState</span>)</a>
<a class="sourceLine" id="cb5-23" title="23"></a>
<a class="sourceLine" id="cb5-24" title="24"><span class="ot">runEval ::</span> <span class="dt">Mem</span> <span class="ot">-&gt;</span> <span class="dt">IChannelMap</span> <span class="ot">-&gt;</span> <span class="dt">OChannelMap</span> <span class="ot">-&gt;</span> <span class="dt">Eval</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb5-25" title="25">runEval memory imap omap (<span class="dt">Eval</span> m) <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-26" title="26">    <span class="fu">fst</span> <span class="fu">&lt;$&gt;</span> evalRWST m env st</a>
<a class="sourceLine" id="cb5-27" title="27">        <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-28" title="28">            env <span class="fu">=</span> <span class="dt">EvalEnv</span> imap omap</a>
<a class="sourceLine" id="cb5-29" title="29">            st <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-30" title="30">                 <span class="dt">EvalState</span></a>
<a class="sourceLine" id="cb5-31" title="31">                     { _iptr <span class="fu">=</span> memStart</a>
<a class="sourceLine" id="cb5-32" title="32">                     , _intStack <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb5-33" title="33">                     , _wptr <span class="fu">=</span> <span class="bn">0xaaaaaaaa</span></a>
<a class="sourceLine" id="cb5-34" title="34">                     , _mem <span class="fu">=</span> memory</a>
<a class="sourceLine" id="cb5-35" title="35">                     }</a></code></pre></div>
<p>The above <code>$(...)</code> is a Template Haskell splice. It creates <em>lenses</em> based on the record declaration of <code>EvalState</code>. Lenses are a very powerful tool that makes it possible to compose record reads and updates in a functional way. Here, it defines a lens for each record field; for example, the splice expands to a top-level declaration <code>iptr :: Lens' EvalState Address</code>. But we will define our own lenses too, and everything will remain composable.</p>
<h2 id="memory">Memory</h2>
<p>This is naturally adapted to byte access:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">memByteOpt ::</span> <span class="dt">Address</span> <span class="ot">-&gt;</span> <span class="dt">Lens&#39;</span> <span class="dt">EvalState</span> (<span class="dt">Maybe</span> <span class="dt">Word8</span>)</a>
<a class="sourceLine" id="cb6-2" title="2">memByteOpt addr <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-3" title="3">  mem <span class="fu">.</span> at addr</a></code></pre></div>
<p>See? We composed the <code>mem</code> lens (between an evaluation state and a memory state) with <code>at addr</code>, which is a lens between a memory state and the value at address <code>addr</code>. Well, not exactly: <code>at</code> actually returns a <code>Maybe Word8</code>. We will assume that all memory accesses will succeed, so we want a lens that returns a plain <code>Word8</code>. To achieve this, we can compose with a lens that treats <code>Maybe a</code> as a container of <code>a</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">maybeLens ::</span> <span class="dt">Lens&#39;</span> (<span class="dt">Maybe</span> a) a</a>
<a class="sourceLine" id="cb7-2" title="2">maybeLens <span class="fu">=</span> lens fromJust (<span class="fu">const</span> <span class="dt">Just</span>)</a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="ot">memByte ::</span> <span class="dt">Address</span> <span class="ot">-&gt;</span> <span class="dt">Lens&#39;</span> <span class="dt">EvalState</span> <span class="dt">Word8</span></a>
<a class="sourceLine" id="cb7-5" title="5">memByte addr <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-6" title="6">  memByteOpt addr <span class="fu">.</span> maybeLens</a></code></pre></div>
<p>Sometimes we will also need to access memory word by word. To achieve that, we first define conversion functions.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">bytesToWord ::</span> (<span class="dt">Word8</span>, <span class="dt">Word8</span>, <span class="dt">Word8</span>, <span class="dt">Word8</span>) <span class="ot">-&gt;</span> <span class="dt">Int32</span></a>
<a class="sourceLine" id="cb8-2" title="2">bytesToWord (b0, b1, b2, b3) <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="fu">sum</span> [ <span class="fu">fromIntegral</span> b0</a>
<a class="sourceLine" id="cb8-4" title="4">        , <span class="fu">fromIntegral</span> b1 <span class="ot">`shiftL`</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb8-5" title="5">        , <span class="fu">fromIntegral</span> b2 <span class="ot">`shiftL`</span> <span class="dv">16</span></a>
<a class="sourceLine" id="cb8-6" title="6">        , <span class="fu">fromIntegral</span> b3 <span class="ot">`shiftL`</span> <span class="dv">24</span></a>
<a class="sourceLine" id="cb8-7" title="7">        ]</a>
<a class="sourceLine" id="cb8-8" title="8"></a>
<a class="sourceLine" id="cb8-9" title="9"><span class="ot">wordToBytes ::</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> (<span class="dt">Word8</span>, <span class="dt">Word8</span>, <span class="dt">Word8</span>, <span class="dt">Word8</span>)</a>
<a class="sourceLine" id="cb8-10" title="10">wordToBytes w <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-11" title="11">    (b0, b1, b2, b3)</a>
<a class="sourceLine" id="cb8-12" title="12">        <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-13" title="13">            b0 <span class="fu">=</span> <span class="fu">fromIntegral</span> <span class="fu">$</span> w <span class="fu">.&amp;.</span> <span class="bn">0x000000ff</span></a>
<a class="sourceLine" id="cb8-14" title="14">            b1 <span class="fu">=</span> <span class="fu">fromIntegral</span> <span class="fu">$</span> (w <span class="fu">.&amp;.</span> <span class="bn">0x0000ff00</span>) <span class="ot">`shiftR`</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb8-15" title="15">            b2 <span class="fu">=</span> <span class="fu">fromIntegral</span> <span class="fu">$</span> (w <span class="fu">.&amp;.</span> <span class="bn">0x00ff0000</span>) <span class="ot">`shiftR`</span> <span class="dv">16</span></a>
<a class="sourceLine" id="cb8-16" title="16">            b3 <span class="fu">=</span> <span class="fu">fromIntegral</span> <span class="fu">$</span> (w <span class="fu">.&amp;.</span> <span class="bn">0xff000000</span>) <span class="ot">`shiftR`</span> <span class="dv">24</span></a></code></pre></div>
<p>Then, we can define a lens focusing on a 32-bit value.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">compose ::</span> [a <span class="ot">-&gt;</span> a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb9-2" title="2">compose <span class="fu">=</span> <span class="fu">foldr</span> (<span class="fu">.</span>) <span class="fu">id</span></a>
<a class="sourceLine" id="cb9-3" title="3"></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="ot">get32 ::</span> <span class="dt">Address</span> <span class="ot">-&gt;</span> <span class="dt">EvalState</span> <span class="ot">-&gt;</span> <span class="dt">Int32</span></a>
<a class="sourceLine" id="cb9-5" title="5">get32 base s <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-6" title="6">    bytesToWord (b0, b1, b2, b3)</a>
<a class="sourceLine" id="cb9-7" title="7">        <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-8" title="8">            b0 <span class="fu">=</span> s <span class="fu">^.</span> memByte base</a>
<a class="sourceLine" id="cb9-9" title="9">            b1 <span class="fu">=</span> s <span class="fu">^.</span> memByte (base <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb9-10" title="10">            b2 <span class="fu">=</span> s <span class="fu">^.</span> memByte (base <span class="fu">+</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb9-11" title="11">            b3 <span class="fu">=</span> s <span class="fu">^.</span> memByte (base <span class="fu">+</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb9-12" title="12"></a>
<a class="sourceLine" id="cb9-13" title="13"><span class="ot">set32 ::</span> <span class="dt">Address</span> <span class="ot">-&gt;</span> <span class="dt">EvalState</span> <span class="ot">-&gt;</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">EvalState</span></a>
<a class="sourceLine" id="cb9-14" title="14">set32 base s v <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-15" title="15">   compose</a>
<a class="sourceLine" id="cb9-16" title="16">       [ set (memByte base) b0</a>
<a class="sourceLine" id="cb9-17" title="17">       , set (memByte (base <span class="fu">+</span> <span class="dv">1</span>)) b1</a>
<a class="sourceLine" id="cb9-18" title="18">       , set (memByte (base <span class="fu">+</span> <span class="dv">2</span>)) b2</a>
<a class="sourceLine" id="cb9-19" title="19">       , set (memByte (base <span class="fu">+</span> <span class="dv">3</span>)) b3</a>
<a class="sourceLine" id="cb9-20" title="20">       ] s</a>
<a class="sourceLine" id="cb9-21" title="21">        <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-22" title="22">            (b0, b1, b2, b3) <span class="fu">=</span> wordToBytes v</a>
<a class="sourceLine" id="cb9-23" title="23"></a>
<a class="sourceLine" id="cb9-24" title="24"><span class="ot">memWord ::</span> <span class="dt">Address</span> <span class="ot">-&gt;</span> <span class="dt">Lens&#39;</span> <span class="dt">EvalState</span> <span class="dt">Int32</span></a>
<a class="sourceLine" id="cb9-25" title="25">memWord addr <span class="fu">=</span> lens (get32 addr) (set32 addr)</a></code></pre></div>
<p>The instruction set reference defines a handy operator to shift an address by a word offset:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">(@@) ::</span> <span class="dt">Address</span> <span class="ot">-&gt;</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">Address</span></a>
<a class="sourceLine" id="cb10-2" title="2">a <span class="fu">@@</span> n <span class="fu">=</span> a <span class="fu">+</span> <span class="dv">4</span> <span class="fu">*</span> n</a></code></pre></div>
<p>It will be also handy to access the memory in list chunks:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">mem8s ::</span> <span class="dt">Address</span> <span class="ot">-&gt;</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">Lens&#39;</span> <span class="dt">EvalState</span> [<span class="dt">Word8</span>]</a>
<a class="sourceLine" id="cb11-2" title="2">mem8s base len <span class="fu">=</span> lens getList setList</a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-4" title="4">        getList s <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-5" title="5">            <span class="fu">map</span> (\ off <span class="ot">-&gt;</span> s <span class="fu">^.</span> memByte (base <span class="fu">+</span> off)) [<span class="dv">0</span> <span class="fu">..</span> len <span class="fu">-</span> <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb11-6" title="6">        setList s0 ws <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-7" title="7">            compose (<span class="fu">zipWith</span> (\ off w <span class="ot">-&gt;</span> set (memByte (base <span class="fu">+</span> off)) w) [<span class="dv">0</span><span class="fu">..</span>] ws) s0</a></code></pre></div>
<h2 id="instruction-decoding">Instruction decoding</h2>
<p>Instructions are usually encoded on a single byte: the opcode is in the first nibble, and a parameter is in the second one. For example this is how a LDC (load constant) is encoded:</p>
<pre><code>   .--- 0x40 LDC
  |.---          0x5
  ||
0x45         LDC 0x5</code></pre>
<p>This only works for 4-bytes constants. To load bigger constants, there is a “prefix” operation that will shift the current operand:</p>
<pre><code>   .-------- 0x20 PFX
  |.--------          0x2
  ||
  ||    .--- 0x40 LDC
  ||   |.---          0x5
  ||   ||
0x22 0x45    LDC 0x25</code></pre>
<p>Those are chainable; for example <code>0x21 0x22 0x45</code> encodes <code>LDC 0x125</code>.</p>
<p>Another prefix shifts and complements the current operand value:</p>
<pre><code>   .-------- 0x60 NFX
  |.--------          0x2
  ||
  ||    .--- 0x40 LDC
  ||   |.---          0x5
  ||   ||
0x62 0x45    LDC (~0x25)</code></pre>
<p>The ST20 architecture actually provides two type of instructions:</p>
<ul>
<li>“primary” instructions such as <code>LDC</code>. Their operand is directly encoded.</li>
<li>“secondary” instructions such as <code>MINT</code> (equivalent to <code>LDC 0x80000000</code>). They do not have operands. On the contrary, they are actually a special case of the first type, using a special <code>OPR n</code> opcode. For example, <code>MINT</code> is <code>OPR 0x42</code>, which is encoded using <code>0x24 0xF2</code>.</li>
</ul>
<p>We know enough to draft an instruction decoder.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">data</span> <span class="dt">PInstr</span> <span class="fu">=</span> <span class="dt">AJW</span>   <span class="fu">|</span> <span class="dt">ADC</span></a>
<a class="sourceLine" id="cb15-2" title="2">            <span class="fu">|</span> <span class="dt">LDC</span>   <span class="fu">|</span> <span class="dt">STL</span></a>
<a class="sourceLine" id="cb15-3" title="3">            <span class="fu">|</span> <span class="dt">LDL</span>   <span class="fu">|</span> <span class="dt">LDNL</span></a>
<a class="sourceLine" id="cb15-4" title="4">            <span class="fu">|</span> <span class="dt">LDLP</span>  <span class="fu">|</span> <span class="dt">LDNLP</span></a>
<a class="sourceLine" id="cb15-5" title="5">            <span class="fu">|</span> <span class="dt">CJ</span>    <span class="fu">|</span> <span class="dt">J</span></a>
<a class="sourceLine" id="cb15-6" title="6">            <span class="fu">|</span> <span class="dt">EQC</span>   <span class="fu">|</span> <span class="dt">CALL</span></a>
<a class="sourceLine" id="cb15-7" title="7">            <span class="fu">|</span> <span class="dt">STNL</span></a>
<a class="sourceLine" id="cb15-8" title="8">    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb15-9" title="9"></a>
<a class="sourceLine" id="cb15-10" title="10"><span class="kw">data</span> <span class="dt">SInstr</span> <span class="fu">=</span> <span class="dt">PROD</span>  <span class="fu">|</span> <span class="dt">MINT</span>   <span class="fu">|</span> <span class="dt">GAJW</span></a>
<a class="sourceLine" id="cb15-11" title="11">            <span class="fu">|</span> <span class="dt">LDPI</span>  <span class="fu">|</span> <span class="dt">OUT</span>    <span class="fu">|</span> <span class="dt">IN</span></a>
<a class="sourceLine" id="cb15-12" title="12">            <span class="fu">|</span> <span class="dt">LB</span>    <span class="fu">|</span> <span class="dt">XOR</span>    <span class="fu">|</span> <span class="dt">SB</span></a>
<a class="sourceLine" id="cb15-13" title="13">            <span class="fu">|</span> <span class="dt">BSUB</span>  <span class="fu">|</span> <span class="dt">SSUB</span>   <span class="fu">|</span> <span class="dt">DUP</span></a>
<a class="sourceLine" id="cb15-14" title="14">            <span class="fu">|</span> <span class="dt">GTx</span>   <span class="fu">|</span> <span class="dt">WSUB</span>   <span class="fu">|</span> <span class="dt">AND</span></a>
<a class="sourceLine" id="cb15-15" title="15">            <span class="fu">|</span> <span class="dt">RET</span>   <span class="fu">|</span> <span class="dt">GCALL</span>  <span class="fu">|</span> <span class="dt">SHR</span></a>
<a class="sourceLine" id="cb15-16" title="16">            <span class="fu">|</span> <span class="dt">SHL</span>   <span class="fu">|</span> <span class="dt">REM</span></a>
<a class="sourceLine" id="cb15-17" title="17">    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb15-18" title="18"></a>
<a class="sourceLine" id="cb15-19" title="19"><span class="kw">data</span> <span class="dt">Instr</span> <span class="fu">=</span> <span class="dt">Pri</span> <span class="dt">PInstr</span> <span class="dt">Int32</span></a>
<a class="sourceLine" id="cb15-20" title="20">           <span class="fu">|</span> <span class="dt">Sec</span> <span class="dt">SInstr</span></a>
<a class="sourceLine" id="cb15-21" title="21">    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</a>
<a class="sourceLine" id="cb15-22" title="22"></a>
<a class="sourceLine" id="cb15-23" title="23"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Instr</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-24" title="24">    <span class="fu">show</span> (<span class="dt">Pri</span> p n) <span class="fu">=</span> <span class="fu">show</span> p <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> <span class="fu">show</span> n</a>
<a class="sourceLine" id="cb15-25" title="25">    <span class="fu">show</span> (<span class="dt">Sec</span> s) <span class="fu">=</span> <span class="fu">show</span> s</a></code></pre></div>
<p>Instruction decoding will need to move within the instruction stream, so it is part of the evaluation monad.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">decodeInstr ::</span> <span class="dt">Eval</span> <span class="dt">Instr</span></a>
<a class="sourceLine" id="cb16-2" title="2">decodeInstr <span class="fu">=</span> decodeInstr_ <span class="dv">0</span></a>
<a class="sourceLine" id="cb16-3" title="3"></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="ot">decodeInstr_ ::</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">Eval</span> <span class="dt">Instr</span></a>
<a class="sourceLine" id="cb16-5" title="5">decodeInstr_ acc <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-6" title="6">    b <span class="ot">&lt;-</span> peekAndIncr</a>
<a class="sourceLine" id="cb16-7" title="7">    <span class="kw">let</span> acc&#39; <span class="fu">=</span> acc <span class="fu">+</span> <span class="fu">fromIntegral</span> (b <span class="fu">.&amp;.</span> <span class="bn">0xf</span>)</a>
<a class="sourceLine" id="cb16-8" title="8">    <span class="kw">case</span> () <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-9" title="9">        _ <span class="fu">|</span> b <span class="fu">&lt;=</span> <span class="bn">0x0f</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Pri</span> <span class="dt">J</span> acc&#39;</a>
<a class="sourceLine" id="cb16-10" title="10">        _ <span class="fu">|</span> b <span class="fu">&lt;=</span> <span class="bn">0x1f</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Pri</span> <span class="dt">LDLP</span> acc&#39;</a>
<a class="sourceLine" id="cb16-11" title="11">        _ <span class="fu">|</span> b <span class="fu">&lt;=</span> <span class="bn">0x2f</span> <span class="ot">-&gt;</span> decodeInstr_ <span class="fu">$</span> acc&#39; <span class="ot">`shiftL`</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb16-12" title="12">        _ <span class="fu">|</span> b <span class="fu">&lt;=</span> <span class="bn">0x3f</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Pri</span> <span class="dt">LDNL</span> acc&#39;</a>
<a class="sourceLine" id="cb16-13" title="13">        _ <span class="fu">|</span> b <span class="fu">&lt;=</span> <span class="bn">0x4f</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Pri</span> <span class="dt">LDC</span> acc&#39;</a>
<a class="sourceLine" id="cb16-14" title="14">        _ <span class="fu">|</span> b <span class="fu">&lt;=</span> <span class="bn">0x5f</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Pri</span> <span class="dt">LDNLP</span> acc&#39;</a>
<a class="sourceLine" id="cb16-15" title="15">        _ <span class="fu">|</span> b <span class="fu">&lt;=</span> <span class="bn">0x6f</span> <span class="ot">-&gt;</span> decodeInstr_ <span class="fu">$</span> complement acc&#39; <span class="ot">`shiftL`</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb16-16" title="16">        _ <span class="fu">|</span> b <span class="fu">&lt;=</span> <span class="bn">0x7f</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Pri</span> <span class="dt">LDL</span> acc&#39;</a>
<a class="sourceLine" id="cb16-17" title="17">        _ <span class="fu">|</span> b <span class="fu">&lt;=</span> <span class="bn">0x8f</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Pri</span> <span class="dt">ADC</span> acc&#39;</a>
<a class="sourceLine" id="cb16-18" title="18">        _ <span class="fu">|</span> b <span class="fu">&lt;=</span> <span class="bn">0x9f</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Pri</span> <span class="dt">CALL</span> acc&#39;</a>
<a class="sourceLine" id="cb16-19" title="19">        _ <span class="fu">|</span> b <span class="fu">&lt;=</span> <span class="bn">0xaf</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Pri</span> <span class="dt">CJ</span> acc&#39;</a>
<a class="sourceLine" id="cb16-20" title="20">        _ <span class="fu">|</span> b <span class="fu">&lt;=</span> <span class="bn">0xbf</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Pri</span> <span class="dt">AJW</span> acc&#39;</a>
<a class="sourceLine" id="cb16-21" title="21">        _ <span class="fu">|</span> b <span class="fu">&lt;=</span> <span class="bn">0xcf</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Pri</span> <span class="dt">EQC</span> acc&#39;</a>
<a class="sourceLine" id="cb16-22" title="22">        _ <span class="fu">|</span> b <span class="fu">&lt;=</span> <span class="bn">0xdf</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Pri</span> <span class="dt">STL</span> acc&#39;</a>
<a class="sourceLine" id="cb16-23" title="23">        _ <span class="fu">|</span> b <span class="fu">&lt;=</span> <span class="bn">0xef</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Pri</span> <span class="dt">STNL</span> acc&#39;</a>
<a class="sourceLine" id="cb16-24" title="24">        _             <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Sec</span> <span class="fu">$</span> parseSecondary acc&#39;</a>
<a class="sourceLine" id="cb16-25" title="25"></a>
<a class="sourceLine" id="cb16-26" title="26"><span class="ot">peekAndIncr ::</span> <span class="dt">Eval</span> <span class="dt">Word8</span></a>
<a class="sourceLine" id="cb16-27" title="27">peekAndIncr <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-28" title="28">    addr <span class="ot">&lt;-</span> use iptr</a>
<a class="sourceLine" id="cb16-29" title="29">    b <span class="ot">&lt;-</span> use (memByte addr)</a>
<a class="sourceLine" id="cb16-30" title="30">    iptr <span class="fu">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb16-31" title="31">    <span class="fu">return</span> b</a>
<a class="sourceLine" id="cb16-32" title="32"></a>
<a class="sourceLine" id="cb16-33" title="33"><span class="ot">parseSecondary ::</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">SInstr</span></a>
<a class="sourceLine" id="cb16-34" title="34">parseSecondary <span class="bn">0x01</span> <span class="fu">=</span> <span class="dt">LB</span></a>
<a class="sourceLine" id="cb16-35" title="35">parseSecondary <span class="bn">0x02</span> <span class="fu">=</span> <span class="dt">BSUB</span></a>
<a class="sourceLine" id="cb16-36" title="36">parseSecondary <span class="bn">0x06</span> <span class="fu">=</span> <span class="dt">GCALL</span></a>
<a class="sourceLine" id="cb16-37" title="37">parseSecondary <span class="bn">0x07</span> <span class="fu">=</span> <span class="dt">IN</span></a>
<a class="sourceLine" id="cb16-38" title="38">parseSecondary <span class="bn">0x08</span> <span class="fu">=</span> <span class="dt">PROD</span></a>
<a class="sourceLine" id="cb16-39" title="39">parseSecondary <span class="bn">0x09</span> <span class="fu">=</span> <span class="dt">GTx</span></a>
<a class="sourceLine" id="cb16-40" title="40">parseSecondary <span class="bn">0x0a</span> <span class="fu">=</span> <span class="dt">WSUB</span></a>
<a class="sourceLine" id="cb16-41" title="41">parseSecondary <span class="bn">0x0b</span> <span class="fu">=</span> <span class="dt">OUT</span></a>
<a class="sourceLine" id="cb16-42" title="42">parseSecondary <span class="bn">0x1b</span> <span class="fu">=</span> <span class="dt">LDPI</span></a>
<a class="sourceLine" id="cb16-43" title="43">parseSecondary <span class="bn">0x1f</span> <span class="fu">=</span> <span class="dt">REM</span></a>
<a class="sourceLine" id="cb16-44" title="44">parseSecondary <span class="bn">0x20</span> <span class="fu">=</span> <span class="dt">RET</span></a>
<a class="sourceLine" id="cb16-45" title="45">parseSecondary <span class="bn">0x33</span> <span class="fu">=</span> <span class="dt">XOR</span></a>
<a class="sourceLine" id="cb16-46" title="46">parseSecondary <span class="bn">0x3b</span> <span class="fu">=</span> <span class="dt">SB</span></a>
<a class="sourceLine" id="cb16-47" title="47">parseSecondary <span class="bn">0x3c</span> <span class="fu">=</span> <span class="dt">GAJW</span></a>
<a class="sourceLine" id="cb16-48" title="48">parseSecondary <span class="bn">0x40</span> <span class="fu">=</span> <span class="dt">SHR</span></a>
<a class="sourceLine" id="cb16-49" title="49">parseSecondary <span class="bn">0x41</span> <span class="fu">=</span> <span class="dt">SHL</span></a>
<a class="sourceLine" id="cb16-50" title="50">parseSecondary <span class="bn">0x42</span> <span class="fu">=</span> <span class="dt">MINT</span></a>
<a class="sourceLine" id="cb16-51" title="51">parseSecondary <span class="bn">0x46</span> <span class="fu">=</span> <span class="dt">AND</span></a>
<a class="sourceLine" id="cb16-52" title="52">parseSecondary <span class="bn">0x5a</span> <span class="fu">=</span> <span class="dt">DUP</span></a>
<a class="sourceLine" id="cb16-53" title="53">parseSecondary <span class="bn">0xc1</span> <span class="fu">=</span> <span class="dt">SSUB</span></a>
<a class="sourceLine" id="cb16-54" title="54">parseSecondary b <span class="fu">=</span> <span class="fu">error</span> <span class="fu">$</span> <span class="st">&quot;Unknown secondary 0x&quot;</span> <span class="fu">++</span> showHex b <span class="st">&quot;&quot;</span></a></code></pre></div>
<h2 id="the-two-stacks">The two stacks</h2>
<p>Data is manipulated using two different mechanisms: the integer stack and the workspace.</p>
<p>The integer stack is a set of three registers: <code>A</code>, <code>B</code>, and <code>C</code>, which can be used as a stack using these operations. Actually, it can only be manipulated through push and pop operations, so we represent this using a list.</p>
<p>The instruction set reference says that an undefined value will be popped if the stack is empty; here we consider that this will not happen, and allow a partial pattern matching.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="ot">pushInt ::</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">Eval</span> ()</a>
<a class="sourceLine" id="cb17-2" title="2">pushInt n <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-3" title="3">    intStack <span class="fu">%=</span> (n<span class="fu">:</span>)</a>
<a class="sourceLine" id="cb17-4" title="4"></a>
<a class="sourceLine" id="cb17-5" title="5"><span class="ot">popInt ::</span> <span class="dt">Eval</span> <span class="dt">Int32</span></a>
<a class="sourceLine" id="cb17-6" title="6">popInt <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-7" title="7">    (h<span class="fu">:</span>t) <span class="ot">&lt;-</span> use intStack</a>
<a class="sourceLine" id="cb17-8" title="8">    intStack <span class="fu">.=</span> t</a>
<a class="sourceLine" id="cb17-9" title="9">    <span class="fu">return</span> h</a>
<a class="sourceLine" id="cb17-10" title="10"></a>
<a class="sourceLine" id="cb17-11" title="11"><span class="ot">popAll ::</span> <span class="dt">Eval</span> (<span class="dt">Int32</span>, <span class="dt">Int32</span>, <span class="dt">Int32</span>)</a>
<a class="sourceLine" id="cb17-12" title="12">popAll <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-13" title="13">    a <span class="ot">&lt;-</span> popInt</a>
<a class="sourceLine" id="cb17-14" title="14">    b <span class="ot">&lt;-</span> popInt</a>
<a class="sourceLine" id="cb17-15" title="15">    c <span class="ot">&lt;-</span> popInt</a>
<a class="sourceLine" id="cb17-16" title="16">    <span class="fu">return</span> (a, b, c)</a></code></pre></div>
<p>Only the head (<code>A</code>) can be directly accessed, so we first define a lens between a list and its head, and compose it with <code>intStack</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="ot">headLens ::</span> <span class="dt">Lens&#39;</span> [a] a</a>
<a class="sourceLine" id="cb18-2" title="2">headLens <span class="fu">=</span> lens <span class="fu">head</span> <span class="fu">$</span> \ l x <span class="ot">-&gt;</span> x<span class="fu">:tail</span> l</a>
<a class="sourceLine" id="cb18-3" title="3"></a>
<a class="sourceLine" id="cb18-4" title="4"><span class="ot">areg ::</span> <span class="dt">Lens&#39;</span> <span class="dt">EvalState</span> <span class="dt">Int32</span></a>
<a class="sourceLine" id="cb18-5" title="5">areg <span class="fu">=</span> intStack <span class="fu">.</span> headLens</a></code></pre></div>
<p>The workspace is a place in memory (pointed to by a register <code>wptr</code>) where local variables can be stored and loaded, a bit like a stack pointer. We first define push and pop operations.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="ot">pushWorkspace ::</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">Eval</span> ()</a>
<a class="sourceLine" id="cb19-2" title="2">pushWorkspace value <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-3" title="3">    wptr <span class="fu">-=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb19-4" title="4">    var <span class="dv">0</span> <span class="fu">.=</span> value</a>
<a class="sourceLine" id="cb19-5" title="5"></a>
<a class="sourceLine" id="cb19-6" title="6"><span class="ot">popWorkspace ::</span> <span class="dt">Eval</span> <span class="dt">Int32</span></a>
<a class="sourceLine" id="cb19-7" title="7">popWorkspace <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-8" title="8">    w <span class="ot">&lt;-</span> use <span class="fu">$</span> var <span class="dv">0</span></a>
<a class="sourceLine" id="cb19-9" title="9">    wptr <span class="fu">+=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb19-10" title="10">    <span class="fu">return</span> w</a></code></pre></div>
<p>Then we define a lens to focus on a variable.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="ot">var ::</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">Lens&#39;</span> <span class="dt">EvalState</span> <span class="dt">Int32</span></a>
<a class="sourceLine" id="cb20-2" title="2">var n <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-3" title="3">    lens getVar setVar</a>
<a class="sourceLine" id="cb20-4" title="4">        <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-5" title="5">            varLens s <span class="fu">=</span> memWord ((s <span class="fu">^.</span> wptr) <span class="fu">@@</span> n)</a>
<a class="sourceLine" id="cb20-6" title="6">            getVar s <span class="fu">=</span> s <span class="fu">^.</span> varLens s</a>
<a class="sourceLine" id="cb20-7" title="7">            setVar s v <span class="fu">=</span> set (varLens s) v s</a></code></pre></div>
<h2 id="input-and-output">Input and output</h2>
<p>The main particularity of the ST20 architecture is that it has hardware support of message channels. They map fairly naturally to <code>Control.Concurrent.Chan</code> channels. Each ST20 thread will have a map from channel numbers to input or output channels:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="ot">getXChan ::</span> (<span class="dt">EvalEnv</span> <span class="ot">-&gt;</span> [(<span class="dt">Int32</span>, a)]) <span class="ot">-&gt;</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">EvalEnv</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb21-2" title="2">getXChan member w st <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-3" title="3">    fromJust <span class="fu">$</span> <span class="fu">lookup</span> w <span class="fu">$</span> member st</a>
<a class="sourceLine" id="cb21-4" title="4"></a>
<a class="sourceLine" id="cb21-5" title="5"><span class="ot">getIChan ::</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">EvalEnv</span> <span class="ot">-&gt;</span> <span class="dt">IChannel</span></a>
<a class="sourceLine" id="cb21-6" title="6">getIChan <span class="fu">=</span> getXChan envInChans</a>
<a class="sourceLine" id="cb21-7" title="7"></a>
<a class="sourceLine" id="cb21-8" title="8"><span class="ot">getOChan ::</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">EvalEnv</span> <span class="ot">-&gt;</span> <span class="dt">OChannel</span></a>
<a class="sourceLine" id="cb21-9" title="9">getOChan <span class="fu">=</span> getXChan envOutChans</a></code></pre></div>
<p>And these channels can be either a <code>Chan Word8</code> or a plain <code>Handle</code>, to connect a thread to the process’ standard input and output.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="ot">readFromIChan ::</span> <span class="dt">IChannel</span> <span class="ot">-&gt;</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">Eval</span> [<span class="dt">Word8</span>]</a>
<a class="sourceLine" id="cb22-2" title="2">readFromIChan (<span class="dt">InChan</span> chan) n <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-3" title="3">    liftIO <span class="fu">$</span> <span class="fu">mapM</span> (\ _ <span class="ot">-&gt;</span> readChan chan) [<span class="dv">1</span><span class="fu">..</span>n]</a>
<a class="sourceLine" id="cb22-4" title="4">readFromIChan (<span class="dt">InHandle</span> h) n <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-5" title="5">    liftIO <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb22-6" title="6">        bs <span class="ot">&lt;-</span> BS.hGet h <span class="fu">$</span> <span class="fu">fromIntegral</span> n</a>
<a class="sourceLine" id="cb22-7" title="7">        <span class="fu">return</span> <span class="fu">$</span> BS.unpack bs</a>
<a class="sourceLine" id="cb22-8" title="8"></a>
<a class="sourceLine" id="cb22-9" title="9"><span class="ot">writeToOChan ::</span> <span class="dt">OChannel</span> <span class="ot">-&gt;</span> [<span class="dt">Word8</span>] <span class="ot">-&gt;</span> <span class="dt">Eval</span> ()</a>
<a class="sourceLine" id="cb22-10" title="10">writeToOChan (<span class="dt">OutChan</span> chan) ws <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-11" title="11">    liftIO <span class="fu">$</span> writeList2Chan chan ws</a>
<a class="sourceLine" id="cb22-12" title="12">writeToOChan (<span class="dt">OutHandle</span> h) ws <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-13" title="13">    liftIO <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb22-14" title="14">        BS.hPutStr h <span class="fu">$</span> BS.pack ws</a>
<a class="sourceLine" id="cb22-15" title="15">        hFlush h</a></code></pre></div>
<h2 id="a-few-combinators">A few combinators</h2>
<p>We first define a few combinators that will help us define the <code>interpret</code> function.</p>
<p>Pop two operands, and push the result:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="ot">liftOp ::</span> (<span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">Int32</span>) <span class="ot">-&gt;</span> <span class="dt">Eval</span> ()</a>
<a class="sourceLine" id="cb23-2" title="2">liftOp op <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-3" title="3">    a <span class="ot">&lt;-</span> popInt</a>
<a class="sourceLine" id="cb23-4" title="4">    b <span class="ot">&lt;-</span> popInt</a>
<a class="sourceLine" id="cb23-5" title="5">    pushInt <span class="fu">$</span> op a b</a></code></pre></div>
<p>Exchange two registers:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="ot">xchg ::</span> <span class="dt">Lens&#39;</span> <span class="dt">EvalState</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">Lens&#39;</span> <span class="dt">EvalState</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">Eval</span> ()</a>
<a class="sourceLine" id="cb24-2" title="2">xchg l1 l2 <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb24-3" title="3">  x1 <span class="ot">&lt;-</span> use l1</a>
<a class="sourceLine" id="cb24-4" title="4">  x2 <span class="ot">&lt;-</span> use l2</a>
<a class="sourceLine" id="cb24-5" title="5">  l1 <span class="fu">.=</span> x2</a>
<a class="sourceLine" id="cb24-6" title="6">  l2 <span class="fu">.=</span> x1</a></code></pre></div>
<p>Convert a boolean to an integer:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1"><span class="ot">fromBool ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int32</span></a>
<a class="sourceLine" id="cb25-2" title="2">fromBool <span class="dt">False</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb25-3" title="3">fromBool <span class="dt">True</span> <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<h2 id="the-interpret-function">The <code>interpret</code> function</h2>
<p>The core of the interpreter is the following function. It takes an instruction and transforms it into a monadic action in <code>Eval</code>.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="ot">interpret ::</span> <span class="dt">Instr</span> <span class="ot">-&gt;</span> <span class="dt">Eval</span> ()</a></code></pre></div>
<p>Some cases are very simple.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1">interpret (<span class="dt">Pri</span> <span class="dt">AJW</span> n) <span class="fu">=</span> wptr <span class="fu">+=</span> <span class="dv">4</span> <span class="fu">*</span> n</a>
<a class="sourceLine" id="cb27-2" title="2">interpret (<span class="dt">Pri</span> <span class="dt">LDNLP</span> n) <span class="fu">=</span> areg <span class="fu">+=</span> <span class="dv">4</span> <span class="fu">*</span> n</a>
<a class="sourceLine" id="cb27-3" title="3">interpret (<span class="dt">Pri</span> <span class="dt">J</span> n) <span class="fu">=</span> iptr <span class="fu">+=</span> n</a>
<a class="sourceLine" id="cb27-4" title="4">interpret (<span class="dt">Pri</span> <span class="dt">LDC</span> n) <span class="fu">=</span> pushInt n</a>
<a class="sourceLine" id="cb27-5" title="5">interpret (<span class="dt">Sec</span> <span class="dt">MINT</span>) <span class="fu">=</span> pushInt <span class="bn">0x80000000</span></a>
<a class="sourceLine" id="cb27-6" title="6">interpret (<span class="dt">Sec</span> <span class="dt">GAJW</span>) <span class="fu">=</span> xchg areg wptr</a>
<a class="sourceLine" id="cb27-7" title="7">interpret (<span class="dt">Sec</span> <span class="dt">GCALL</span>) <span class="fu">=</span> xchg areg iptr</a>
<a class="sourceLine" id="cb27-8" title="8">interpret (<span class="dt">Pri</span> <span class="dt">ADC</span> n) <span class="fu">=</span> areg <span class="fu">+=</span> n</a>
<a class="sourceLine" id="cb27-9" title="9">interpret (<span class="dt">Pri</span> <span class="dt">EQC</span> n) <span class="fu">=</span> areg <span class="fu">%=</span> (\ a <span class="ot">-&gt;</span> fromBool <span class="fu">$</span> a <span class="fu">==</span> n)</a></code></pre></div>
<p>For some others, we can lift them into the host language and use Haskell operations.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1">interpret (<span class="dt">Sec</span> <span class="dt">PROD</span>) <span class="fu">=</span> liftOp (<span class="fu">*</span>)</a>
<a class="sourceLine" id="cb28-2" title="2">interpret (<span class="dt">Sec</span> <span class="dt">XOR</span>) <span class="fu">=</span> liftOp xor</a>
<a class="sourceLine" id="cb28-3" title="3">interpret (<span class="dt">Sec</span> <span class="dt">AND</span>) <span class="fu">=</span> liftOp (<span class="fu">.&amp;.</span>)</a>
<a class="sourceLine" id="cb28-4" title="4">interpret (<span class="dt">Sec</span> <span class="dt">BSUB</span>) <span class="fu">=</span> liftOp (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb28-5" title="5">interpret (<span class="dt">Sec</span> <span class="dt">SSUB</span>) <span class="fu">=</span> liftOp <span class="fu">$</span> \ a b <span class="ot">-&gt;</span> a <span class="fu">+</span> <span class="dv">2</span> <span class="fu">*</span> b</a>
<a class="sourceLine" id="cb28-6" title="6">interpret (<span class="dt">Sec</span> <span class="dt">WSUB</span>) <span class="fu">=</span> liftOp (<span class="fu">@@</span>)</a>
<a class="sourceLine" id="cb28-7" title="7">interpret (<span class="dt">Sec</span> <span class="dt">GTx</span>) <span class="fu">=</span> liftOp <span class="fu">$</span> \ a b <span class="ot">-&gt;</span> fromBool <span class="fu">$</span> b <span class="fu">&gt;</span> a</a>
<a class="sourceLine" id="cb28-8" title="8">interpret (<span class="dt">Sec</span> <span class="dt">SHR</span>) <span class="fu">=</span> liftOp <span class="fu">$</span> \ a b <span class="ot">-&gt;</span> b <span class="ot">`shiftR`</span> <span class="fu">fromIntegral</span> a</a>
<a class="sourceLine" id="cb28-9" title="9">interpret (<span class="dt">Sec</span> <span class="dt">SHL</span>) <span class="fu">=</span> liftOp <span class="fu">$</span> \ a b <span class="ot">-&gt;</span> b <span class="ot">`shiftL`</span> <span class="fu">fromIntegral</span> a</a>
<a class="sourceLine" id="cb28-10" title="10">interpret (<span class="dt">Sec</span> <span class="dt">REM</span>) <span class="fu">=</span> liftOp <span class="fu">$</span> \ a b <span class="ot">-&gt;</span> b <span class="ot">`mod`</span> a</a></code></pre></div>
<p>Others need a few operations to prepare the operands and access memory.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1">interpret (<span class="dt">Sec</span> <span class="dt">SB</span>) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb29-2" title="2">    a <span class="ot">&lt;-</span> popInt</a>
<a class="sourceLine" id="cb29-3" title="3">    b <span class="ot">&lt;-</span> popInt</a>
<a class="sourceLine" id="cb29-4" title="4">    memByte a <span class="fu">.=</span> <span class="fu">fromIntegral</span> b</a>
<a class="sourceLine" id="cb29-5" title="5">interpret (<span class="dt">Sec</span> <span class="dt">DUP</span>) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb29-6" title="6">    a <span class="ot">&lt;-</span> popInt</a>
<a class="sourceLine" id="cb29-7" title="7">    pushInt a</a>
<a class="sourceLine" id="cb29-8" title="8">    pushInt a</a>
<a class="sourceLine" id="cb29-9" title="9">interpret (<span class="dt">Pri</span> <span class="dt">STL</span> n) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb29-10" title="10">    v <span class="ot">&lt;-</span> popInt</a>
<a class="sourceLine" id="cb29-11" title="11">    var n <span class="fu">.=</span> v</a>
<a class="sourceLine" id="cb29-12" title="12">interpret (<span class="dt">Pri</span> <span class="dt">LDLP</span> n) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb29-13" title="13">    v <span class="ot">&lt;-</span> use wptr</a>
<a class="sourceLine" id="cb29-14" title="14">    pushInt <span class="fu">$</span> v <span class="fu">@@</span> n</a>
<a class="sourceLine" id="cb29-15" title="15">interpret (<span class="dt">Pri</span> <span class="dt">LDL</span> n) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb29-16" title="16">    v <span class="ot">&lt;-</span> use <span class="fu">$</span> var n</a>
<a class="sourceLine" id="cb29-17" title="17">    pushInt v</a>
<a class="sourceLine" id="cb29-18" title="18">interpret (<span class="dt">Sec</span> <span class="dt">LDPI</span>) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb29-19" title="19">    ip <span class="ot">&lt;-</span> use iptr</a>
<a class="sourceLine" id="cb29-20" title="20">    areg <span class="fu">+=</span> ip</a>
<a class="sourceLine" id="cb29-21" title="21">interpret (<span class="dt">Pri</span> <span class="dt">CJ</span> n) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb29-22" title="22">    a <span class="ot">&lt;-</span> popInt</a>
<a class="sourceLine" id="cb29-23" title="23">    <span class="kw">let</span> d <span class="fu">=</span> <span class="kw">if</span> a <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> n <span class="kw">else</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb29-24" title="24">    iptr <span class="fu">+=</span> d</a>
<a class="sourceLine" id="cb29-25" title="25">interpret (<span class="dt">Sec</span> <span class="dt">LB</span>) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb29-26" title="26">    a <span class="ot">&lt;-</span> use areg</a>
<a class="sourceLine" id="cb29-27" title="27">    a&#39; <span class="ot">&lt;-</span> <span class="fu">fromIntegral</span> <span class="fu">&lt;$&gt;</span> use (memByte a)</a>
<a class="sourceLine" id="cb29-28" title="28">    areg <span class="fu">.=</span> a&#39;</a>
<a class="sourceLine" id="cb29-29" title="29">interpret (<span class="dt">Pri</span> <span class="dt">STNL</span> n) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb29-30" title="30">    a <span class="ot">&lt;-</span> popInt</a>
<a class="sourceLine" id="cb29-31" title="31">    b <span class="ot">&lt;-</span> popInt</a>
<a class="sourceLine" id="cb29-32" title="32">    memWord (a <span class="fu">@@</span> n) <span class="fu">.=</span> b</a>
<a class="sourceLine" id="cb29-33" title="33">interpret (<span class="dt">Pri</span> <span class="dt">LDNL</span> n) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb29-34" title="34">    a <span class="ot">&lt;-</span> use areg</a>
<a class="sourceLine" id="cb29-35" title="35">    a&#39; <span class="ot">&lt;-</span> use <span class="fu">$</span> memWord <span class="fu">$</span> a <span class="fu">@@</span> n</a>
<a class="sourceLine" id="cb29-36" title="36">    areg <span class="fu">.=</span> a&#39;</a></code></pre></div>
<p>Call and return instructions use the workspace to pass arguments.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1">interpret (<span class="dt">Pri</span> <span class="dt">CALL</span> n) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb30-2" title="2">    (a, b, c) <span class="ot">&lt;-</span> popAll</a>
<a class="sourceLine" id="cb30-3" title="3">    pushWorkspace c</a>
<a class="sourceLine" id="cb30-4" title="4">    pushWorkspace b</a>
<a class="sourceLine" id="cb30-5" title="5">    pushWorkspace a</a>
<a class="sourceLine" id="cb30-6" title="6">    ip <span class="ot">&lt;-</span> use iptr</a>
<a class="sourceLine" id="cb30-7" title="7">    pushWorkspace ip</a>
<a class="sourceLine" id="cb30-8" title="8">    areg <span class="fu">.=</span> ip</a>
<a class="sourceLine" id="cb30-9" title="9">    iptr <span class="fu">+=</span> n</a>
<a class="sourceLine" id="cb30-10" title="10">interpret (<span class="dt">Sec</span> <span class="dt">RET</span>) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb30-11" title="11">    newIp <span class="ot">&lt;-</span> popWorkspace</a>
<a class="sourceLine" id="cb30-12" title="12">    _ <span class="ot">&lt;-</span> popWorkspace</a>
<a class="sourceLine" id="cb30-13" title="13">    _ <span class="ot">&lt;-</span> popWorkspace</a>
<a class="sourceLine" id="cb30-14" title="14">    _ <span class="ot">&lt;-</span> popWorkspace</a>
<a class="sourceLine" id="cb30-15" title="15">    iptr <span class="fu">.=</span> newIp</a></code></pre></div>
<p>To perform I/O, the calling transputer needs to supply three things in the int stack:</p>
<ul>
<li>the number of bytes to transfer;</li>
<li>a pointer to a channel;</li>
<li>where to read or write the message.</li>
</ul>
<p>The channel itself is abstracted in the transputer’s channel maps. Most reads succeed; however the first transputer’s channel 0 will read directly from a file, so it will reach end of file at some time. We can detect that when an empty list is read, and exit the process.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1">interpret (<span class="dt">Sec</span> <span class="dt">OUT</span>) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb31-2" title="2">    (len, pChan, pMsg) <span class="ot">&lt;-</span> popAll</a>
<a class="sourceLine" id="cb31-3" title="3">    message <span class="ot">&lt;-</span> use <span class="fu">$</span> mem8s pMsg len</a>
<a class="sourceLine" id="cb31-4" title="4">    chan <span class="ot">&lt;-</span> asks <span class="fu">$</span> getOChan pChan</a>
<a class="sourceLine" id="cb31-5" title="5">    writeToOChan chan message</a>
<a class="sourceLine" id="cb31-6" title="6">interpret (<span class="dt">Sec</span> <span class="dt">IN</span>) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb31-7" title="7">    (len, pChan, pMsg) <span class="ot">&lt;-</span> popAll</a>
<a class="sourceLine" id="cb31-8" title="8">    chan <span class="ot">&lt;-</span> asks <span class="fu">$</span> getIChan pChan</a>
<a class="sourceLine" id="cb31-9" title="9">    input <span class="ot">&lt;-</span> readFromIChan chan len</a>
<a class="sourceLine" id="cb31-10" title="10">    when (<span class="fu">null</span> input) <span class="fu">$</span> liftIO exitSuccess</a>
<a class="sourceLine" id="cb31-11" title="11">    mem8s pMsg (<span class="fu">fromIntegral</span> <span class="fu">$</span> <span class="fu">length</span> input) <span class="fu">.=</span> input</a></code></pre></div>
<p>The core of the interpreter is then very simple:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1"><span class="ot">evalLoop ::</span> <span class="dt">Eval</span> ()</a>
<a class="sourceLine" id="cb32-2" title="2">evalLoop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb32-3" title="3">    i <span class="ot">&lt;-</span> decodeInstr</a>
<a class="sourceLine" id="cb32-4" title="4">    interpret i</a>
<a class="sourceLine" id="cb32-5" title="5">    evalLoop</a></code></pre></div>
<h2 id="boot-from-link">Boot from link</h2>
<p>Several things are missing: the memory map, and how the system boots.</p>
<p>It turns out that the ST20 has a very simple boot protocol:</p>
<ul>
<li>read 1 byte from port 0, call it <code>n</code></li>
<li>read <code>n</code> bytes from port 0</li>
<li>store those at <code>memStart</code></li>
<li>set the workspace just after this memory chunk</li>
<li>jump to <code>memStart</code></li>
</ul>
<div class="sourceCode" id="cb33"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1"><span class="ot">bootSeq ::</span> <span class="dt">Eval</span> ()</a>
<a class="sourceLine" id="cb33-2" title="2">bootSeq <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb33-3" title="3">    chan <span class="ot">&lt;-</span> asks <span class="fu">$</span> getIChan <span class="fu">$</span> iPin <span class="dv">0</span></a>
<a class="sourceLine" id="cb33-4" title="4">    len <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="fu">&lt;$&gt;</span> readFromIChan chan <span class="dv">1</span></a>
<a class="sourceLine" id="cb33-5" title="5">    prog <span class="ot">&lt;-</span> readFromIChan chan <span class="fu">$</span> <span class="fu">fromIntegral</span> len</a>
<a class="sourceLine" id="cb33-6" title="6">    mem8s memStart (<span class="fu">fromIntegral</span> <span class="fu">$</span> <span class="fu">length</span> prog) <span class="fu">.=</span> prog</a>
<a class="sourceLine" id="cb33-7" title="7">    wptr <span class="fu">.=</span> memStart <span class="fu">+</span> <span class="fu">fromIntegral</span> len</a></code></pre></div>
<p>There’s some flexibility on <code>memStart</code>, but this value works:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1"><span class="ot">memStart ::</span> <span class="dt">Address</span></a>
<a class="sourceLine" id="cb34-2" title="2">memStart <span class="fu">=</span> <span class="bn">0x80000100</span></a></code></pre></div>
<p>Pin numbers, however, are mapped to fixed address:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" title="1"><span class="ot">iPin ::</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">Int32</span></a>
<a class="sourceLine" id="cb35-2" title="2">iPin n <span class="fu">=</span> <span class="bn">0x80000010</span> <span class="fu">@@</span> n</a>
<a class="sourceLine" id="cb35-3" title="3"></a>
<a class="sourceLine" id="cb35-4" title="4"><span class="ot">oPin ::</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">Int32</span></a>
<a class="sourceLine" id="cb35-5" title="5">oPin n <span class="fu">=</span> <span class="bn">0x80000000</span> <span class="fu">@@</span> n</a></code></pre></div>
<p>We decide to initialize the memory with zeroes:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1"><span class="ot">initialMem ::</span> <span class="dt">Mem</span></a>
<a class="sourceLine" id="cb36-2" title="2">initialMem <span class="fu">=</span></a>
<a class="sourceLine" id="cb36-3" title="3">    M.fromList <span class="fu">$</span> <span class="fu">zip</span> [<span class="bn">0x80000000</span> <span class="fu">..</span> memEnd] <span class="fu">$</span> <span class="fu">repeat</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb36-4" title="4">        <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-5" title="5">            memSize <span class="fu">=</span> <span class="bn">0x4000</span></a>
<a class="sourceLine" id="cb36-6" title="6">            memEnd <span class="fu">=</span> memStart <span class="fu">+</span> memSize <span class="fu">-</span> <span class="dv">1</span></a></code></pre></div>
<p>Booting a transputer is then just a matter of reading from the correct channel and doing the rest of the evaluation loop.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" title="1"><span class="ot">transputer ::</span> <span class="dt">Maybe</span> <span class="dt">Analysis</span></a>
<a class="sourceLine" id="cb37-2" title="2">           <span class="ot">-&gt;</span> [((<span class="dt">Int32</span>, <span class="dt">IChannel</span>), (<span class="dt">Int32</span>, <span class="dt">OChannel</span>))]</a>
<a class="sourceLine" id="cb37-3" title="3">           <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">MVar</span> ())</a>
<a class="sourceLine" id="cb37-4" title="4">transputer analysis cmap <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb37-5" title="5">    <span class="kw">let</span> (imap, omap) <span class="fu">=</span> <span class="fu">unzip</span> cmap</a>
<a class="sourceLine" id="cb37-6" title="6">    fork <span class="fu">$</span> runEval initialMem imap omap <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb37-7" title="7">        bootSeq</a>
<a class="sourceLine" id="cb37-8" title="8">        runAnalysis analysis</a>
<a class="sourceLine" id="cb37-9" title="9">        evalLoop</a></code></pre></div>
<h2 id="multithreading-boilerplate">Multithreading boilerplate</h2>
<p>If you fork threads and don’t wait for them, nothing will happen since the main thread will just exit. The solution is to create a “control” <code>MVar</code> that will be signalled to by each thread:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" title="1"><span class="ot">fork ::</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">MVar</span> ())</a>
<a class="sourceLine" id="cb38-2" title="2">fork io <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb38-3" title="3">    mvar <span class="ot">&lt;-</span> newEmptyMVar</a>
<a class="sourceLine" id="cb38-4" title="4">    _ <span class="ot">&lt;-</span> forkFinally io <span class="fu">$</span> \ _ <span class="ot">-&gt;</span> putMVar mvar ()</a>
<a class="sourceLine" id="cb38-5" title="5">    <span class="fu">return</span> mvar</a></code></pre></div>
<p>And to wait for all of them:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" title="1"><span class="ot">runAll ::</span> [<span class="dt">IO</span> (<span class="dt">MVar</span> ())] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb39-2" title="2">runAll ms <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb39-3" title="3">    threads <span class="ot">&lt;-</span> <span class="fu">sequence</span> ms</a>
<a class="sourceLine" id="cb39-4" title="4">    <span class="fu">mapM_</span> takeMVar threads</a></code></pre></div>
<h2 id="connecting-the-lines">Connecting the lines</h2>
<p>For this problem we have 13 transputers.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" title="1"><span class="kw">data</span> <span class="dt">TransputerName</span> <span class="fu">=</span> <span class="dt">T00</span> <span class="fu">|</span> <span class="dt">T01</span> <span class="fu">|</span> <span class="dt">T02</span> <span class="fu">|</span> <span class="dt">T03</span></a>
<a class="sourceLine" id="cb40-2" title="2">                    <span class="fu">|</span> <span class="dt">T04</span> <span class="fu">|</span> <span class="dt">T05</span> <span class="fu">|</span> <span class="dt">T06</span> <span class="fu">|</span> <span class="dt">T07</span></a>
<a class="sourceLine" id="cb40-3" title="3">                    <span class="fu">|</span> <span class="dt">T08</span> <span class="fu">|</span> <span class="dt">T09</span> <span class="fu">|</span> <span class="dt">T10</span> <span class="fu">|</span> <span class="dt">T11</span></a>
<a class="sourceLine" id="cb40-4" title="4">                    <span class="fu">|</span> <span class="dt">T12</span></a>
<a class="sourceLine" id="cb40-5" title="5">  <span class="kw">deriving</span> (<span class="dt">Enum</span>, <span class="dt">Eq</span>)</a></code></pre></div>
<p>We devise a way to connect them together. The communication between two transputers is bidirectional, so we need two channels. Each of them is converted to an <code>OChannel</code> on one side and an <code>IChannel</code> on the other one.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" title="1"><span class="ot">connect ::</span> <span class="dt">TransputerName</span> <span class="ot">-&gt;</span> <span class="dt">Int32</span></a>
<a class="sourceLine" id="cb41-2" title="2">        <span class="ot">-&gt;</span> <span class="dt">TransputerName</span> <span class="ot">-&gt;</span> <span class="dt">Int32</span></a>
<a class="sourceLine" id="cb41-3" title="3">        <span class="ot">-&gt;</span> <span class="dt">IO</span> [(<span class="dt">TransputerName</span>, <span class="dt">Int32</span>, <span class="dt">OChannel</span>, <span class="dt">IChannel</span>)]</a>
<a class="sourceLine" id="cb41-4" title="4">connect src srcPort dst dstPort <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb41-5" title="5">  x <span class="ot">&lt;-</span> newChan</a>
<a class="sourceLine" id="cb41-6" title="6">  y <span class="ot">&lt;-</span> newChan</a>
<a class="sourceLine" id="cb41-7" title="7">  <span class="fu">return</span> [ (src, srcPort, <span class="dt">OutChan</span> x, <span class="dt">InChan</span> y)</a>
<a class="sourceLine" id="cb41-8" title="8">         , (dst, dstPort, <span class="dt">OutChan</span> y, <span class="dt">InChan</span> x)</a>
<a class="sourceLine" id="cb41-9" title="9">         ]</a></code></pre></div>
<p>Booting them is a matter of creating the correct communication channels (this pinout list comes from a schematic that was present in the challenge files).</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb42-2" title="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb42-3" title="3">    pins <span class="ot">&lt;-</span> <span class="fu">concat</span> <span class="fu">&lt;$&gt;</span> <span class="fu">sequence</span></a>
<a class="sourceLine" id="cb42-4" title="4">        [ connect <span class="dt">T00</span> <span class="dv">1</span> <span class="dt">T01</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb42-5" title="5">        , connect <span class="dt">T00</span> <span class="dv">2</span> <span class="dt">T02</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb42-6" title="6">        , connect <span class="dt">T00</span> <span class="dv">3</span> <span class="dt">T03</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb42-7" title="7">        , connect <span class="dt">T01</span> <span class="dv">1</span> <span class="dt">T04</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb42-8" title="8">        , connect <span class="dt">T01</span> <span class="dv">2</span> <span class="dt">T05</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb42-9" title="9">        , connect <span class="dt">T01</span> <span class="dv">3</span> <span class="dt">T06</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb42-10" title="10">        , connect <span class="dt">T02</span> <span class="dv">1</span> <span class="dt">T07</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb42-11" title="11">        , connect <span class="dt">T02</span> <span class="dv">2</span> <span class="dt">T08</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb42-12" title="12">        , connect <span class="dt">T02</span> <span class="dv">3</span> <span class="dt">T09</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb42-13" title="13">        , connect <span class="dt">T03</span> <span class="dv">1</span> <span class="dt">T10</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb42-14" title="14">        , connect <span class="dt">T03</span> <span class="dv">2</span> <span class="dt">T11</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb42-15" title="15">        , connect <span class="dt">T03</span> <span class="dv">3</span> <span class="dt">T12</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb42-16" title="16">        , connect <span class="dt">T11</span> <span class="dv">1</span> <span class="dt">T12</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb42-17" title="17">        ]</a>
<a class="sourceLine" id="cb42-18" title="18">    runAll <span class="fu">$</span> <span class="fu">map</span> (buildTransputer pins) [<span class="dt">T00</span> <span class="fu">..</span>]</a>
<a class="sourceLine" id="cb42-19" title="19">        <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-20" title="20">            buildTransputer pins t <span class="fu">=</span></a>
<a class="sourceLine" id="cb42-21" title="21">                transputer (isDebug t) <span class="fu">$</span> onlyFor t pins <span class="fu">++</span> extraPins t</a>
<a class="sourceLine" id="cb42-22" title="22">            pin n ochan ichan <span class="fu">=</span> ((iPin n, ichan), (oPin n, ochan))</a>
<a class="sourceLine" id="cb42-23" title="23">            onlyFor src l <span class="fu">=</span> [pin p oc ic <span class="fu">|</span> (name, p, oc, ic) <span class="ot">&lt;-</span> l, name <span class="fu">==</span> src]</a>
<a class="sourceLine" id="cb42-24" title="24">            extraPins <span class="dt">T00</span> <span class="fu">=</span> [((iPin <span class="dv">0</span>, <span class="dt">InHandle</span> stdin), (oPin <span class="dv">0</span>, <span class="dt">OutHandle</span> stdout))]</a>
<a class="sourceLine" id="cb42-25" title="25">            extraPins _ <span class="fu">=</span> []</a></code></pre></div>
<h2 id="bonus-static-analysis-tools">Bonus: static analysis tools</h2>
<p>The above <code>transputer</code> function is controlled by the following configuration:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" title="1"><span class="kw">data</span> <span class="dt">Analysis</span> <span class="fu">=</span> <span class="dt">Graph</span> <span class="fu">|</span> <span class="dt">Disasm</span></a>
<a class="sourceLine" id="cb43-2" title="2"></a>
<a class="sourceLine" id="cb43-3" title="3"><span class="ot">isDebug ::</span> <span class="dt">TransputerName</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Analysis</span></a>
<a class="sourceLine" id="cb43-4" title="4">isDebug _ <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>It means that for each transputer, we can choose to print a graph or a disassembly of the code that will be executed. To do that, we will first compute the set of all edges in the control flow graph.</p>
<p>This analysis relies on a <code>nextInstr</code> function that statically computes the set of next instructions. These can be reached either because it’s the next one in the instruction flow (<code>DSeq</code>), because of jump (<code>DJmp</code>), or an unknown destination, for example after a <code>RET</code> (<code>DDyn</code>).</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" title="1"><span class="kw">data</span> <span class="dt">Dest</span> <span class="fu">=</span> <span class="dt">DSeq</span> <span class="dt">Address</span></a>
<a class="sourceLine" id="cb44-2" title="2">          <span class="fu">|</span> <span class="dt">DJmp</span> <span class="dt">Address</span></a>
<a class="sourceLine" id="cb44-3" title="3">          <span class="fu">|</span> <span class="dt">DDyn</span></a>
<a class="sourceLine" id="cb44-4" title="4">    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</a>
<a class="sourceLine" id="cb44-5" title="5"></a>
<a class="sourceLine" id="cb44-6" title="6"><span class="ot">nextInstrs ::</span> <span class="dt">Instr</span> <span class="ot">-&gt;</span> [<span class="dt">Dest</span>]</a>
<a class="sourceLine" id="cb44-7" title="7">nextInstrs (<span class="dt">Pri</span> <span class="dt">CJ</span> n) <span class="fu">=</span> [<span class="dt">DSeq</span> <span class="dv">0</span>, <span class="dt">DJmp</span> n]</a>
<a class="sourceLine" id="cb44-8" title="8">nextInstrs (<span class="dt">Pri</span> <span class="dt">J</span> n) <span class="fu">=</span> [<span class="dt">DJmp</span> n]</a>
<a class="sourceLine" id="cb44-9" title="9">nextInstrs (<span class="dt">Pri</span> <span class="dt">CALL</span> n) <span class="fu">=</span> [<span class="dt">DSeq</span> <span class="dv">0</span>, <span class="dt">DJmp</span> n]</a>
<a class="sourceLine" id="cb44-10" title="10">nextInstrs (<span class="dt">Sec</span> <span class="dt">GCALL</span>) <span class="fu">=</span> [<span class="dt">DDyn</span>]</a>
<a class="sourceLine" id="cb44-11" title="11">nextInstrs (<span class="dt">Sec</span> <span class="dt">RET</span>) <span class="fu">=</span> [<span class="dt">DDyn</span>]</a>
<a class="sourceLine" id="cb44-12" title="12">nextInstrs _ <span class="fu">=</span> [<span class="dt">DSeq</span> <span class="dv">0</span>]</a></code></pre></div>
<p>We can wrap this function in a monadic one that can turn these relative addresses into absolute ones (since it can know the addresses of functions).</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" title="1"><span class="kw">type</span> <span class="dt">EdgeSet</span> <span class="fu">=</span> <span class="dt">S.Set</span> (<span class="dt">Address</span>, <span class="dt">Instr</span>, <span class="dt">Dest</span>)</a>
<a class="sourceLine" id="cb45-2" title="2"></a>
<a class="sourceLine" id="cb45-3" title="3"><span class="ot">instrDests ::</span> <span class="dt">Address</span> <span class="ot">-&gt;</span> <span class="dt">Eval</span> <span class="dt">EdgeSet</span></a>
<a class="sourceLine" id="cb45-4" title="4">instrDests start <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb45-5" title="5">    iptr <span class="fu">.=</span> start</a>
<a class="sourceLine" id="cb45-6" title="6">    i <span class="ot">&lt;-</span> decodeInstr</a>
<a class="sourceLine" id="cb45-7" title="7">    <span class="kw">let</span> deltaips <span class="fu">=</span> nextInstrs i</a>
<a class="sourceLine" id="cb45-8" title="8">    new <span class="ot">&lt;-</span> use iptr</a>
<a class="sourceLine" id="cb45-9" title="9">    <span class="fu">return</span> <span class="fu">$</span> S.fromList <span class="fu">$</span> <span class="fu">map</span> (\ d <span class="ot">-&gt;</span> (start, i, adjust new d)) deltaips</a>
<a class="sourceLine" id="cb45-10" title="10">        <span class="kw">where</span></a>
<a class="sourceLine" id="cb45-11" title="11">            adjust n (<span class="dt">DSeq</span> d) <span class="fu">=</span> <span class="dt">DSeq</span> <span class="fu">$</span> n <span class="fu">+</span> d</a>
<a class="sourceLine" id="cb45-12" title="12">            adjust n (<span class="dt">DJmp</span> d) <span class="fu">=</span> <span class="dt">DJmp</span> <span class="fu">$</span> n <span class="fu">+</span> d</a>
<a class="sourceLine" id="cb45-13" title="13">            adjust _ <span class="dt">DDyn</span> <span class="fu">=</span> <span class="dt">DDyn</span></a></code></pre></div>
<p>Then, the algorithm consists in computing the fixpoint of the following iterating function:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" title="1"><span class="ot">step ::</span> <span class="dt">EdgeSet</span> <span class="ot">-&gt;</span> <span class="dt">Eval</span> <span class="dt">EdgeSet</span></a>
<a class="sourceLine" id="cb46-2" title="2">step s <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb46-3" title="3">    xs <span class="ot">&lt;-</span> <span class="fu">mapM</span> (basicBlockM <span class="fu">.</span> getDest) <span class="fu">$</span> S.toList s</a>
<a class="sourceLine" id="cb46-4" title="4">    <span class="fu">return</span> <span class="fu">$</span> S.union s <span class="fu">$</span> S.unions xs</a>
<a class="sourceLine" id="cb46-5" title="5">        <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-6" title="6">            getDest (_, _, <span class="dt">DSeq</span> a) <span class="fu">=</span> <span class="dt">Just</span> a</a>
<a class="sourceLine" id="cb46-7" title="7">            getDest (_, _, <span class="dt">DJmp</span> a) <span class="fu">=</span> <span class="dt">Just</span> a</a>
<a class="sourceLine" id="cb46-8" title="8">            getDest (_, _, <span class="dt">DDyn</span>) <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb46-9" title="9">            basicBlockM (<span class="dt">Just</span> a) <span class="fu">=</span> instrDests a</a>
<a class="sourceLine" id="cb46-10" title="10">            basicBlockM <span class="dt">Nothing</span> <span class="fu">=</span> <span class="fu">return</span> S.empty</a></code></pre></div>
<p>The fixpoint itself is computed using the following function, which takes a predicate on two <code>EdgeSet</code>s to stop the iteration.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" title="1"><span class="ot">stepUntil ::</span> ((<span class="dt">EdgeSet</span>, <span class="dt">EdgeSet</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (<span class="dt">EdgeSet</span>, <span class="dt">EdgeSet</span>) <span class="ot">-&gt;</span> <span class="dt">Eval</span> <span class="dt">EdgeSet</span></a>
<a class="sourceLine" id="cb47-2" title="2">stepUntil p (a, b) <span class="fu">|</span> p (a, b) <span class="fu">=</span> <span class="fu">return</span> b</a>
<a class="sourceLine" id="cb47-3" title="3">stepUntil p (_, b) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb47-4" title="4">    c <span class="ot">&lt;-</span> step b</a>
<a class="sourceLine" id="cb47-5" title="5">    stepUntil p (b, c)</a></code></pre></div>
<p>We’ll stop when their size is equal.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" title="1"><span class="ot">runAnalysis ::</span> <span class="dt">Maybe</span> <span class="dt">Analysis</span> <span class="ot">-&gt;</span> <span class="dt">Eval</span> ()</a>
<a class="sourceLine" id="cb48-2" title="2">runAnalysis <span class="dt">Nothing</span> <span class="fu">=</span> <span class="fu">return</span> ()</a>
<a class="sourceLine" id="cb48-3" title="3">runAnalysis (<span class="dt">Just</span> analysis) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb48-4" title="4">    s0 <span class="ot">&lt;-</span> instrDests memStart</a>
<a class="sourceLine" id="cb48-5" title="5">    <span class="kw">let</span> p (a, b) <span class="fu">=</span> S.size a <span class="fu">==</span> S.size b</a>
<a class="sourceLine" id="cb48-6" title="6">    r <span class="ot">&lt;-</span> stepUntil p (S.empty, s0)</a>
<a class="sourceLine" id="cb48-7" title="7">    liftIO <span class="fu">$</span> <span class="fu">putStrLn</span> <span class="fu">$</span> convert analysis r</a>
<a class="sourceLine" id="cb48-8" title="8">    iptr <span class="fu">.=</span> memStart</a></code></pre></div>
<p>Finally, here is how to convert the <code>EdgeSet</code>s in a human-readable form.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" title="1"><span class="ot">convert ::</span> <span class="dt">Analysis</span> <span class="ot">-&gt;</span> <span class="dt">EdgeSet</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb49-2" title="2">convert <span class="dt">Graph</span> es <span class="fu">=</span></a>
<a class="sourceLine" id="cb49-3" title="3">    <span class="st">&quot;digraph G{\n&quot;</span></a>
<a class="sourceLine" id="cb49-4" title="4">    <span class="fu">++</span> <span class="st">&quot;node[shape=point]\n&quot;</span></a>
<a class="sourceLine" id="cb49-5" title="5">    <span class="fu">++</span> <span class="fu">concatMap</span> edge (S.toList es)</a>
<a class="sourceLine" id="cb49-6" title="6">    <span class="fu">++</span> <span class="st">&quot;}&quot;</span></a>
<a class="sourceLine" id="cb49-7" title="7">        <span class="kw">where</span></a>
<a class="sourceLine" id="cb49-8" title="8">            edge (x, i, y) <span class="fu">=</span> <span class="fu">show</span> x <span class="fu">++</span> <span class="st">&quot; -&gt; &quot;</span> <span class="fu">++</span> toNode x y <span class="fu">++</span> <span class="st">&quot;[label=\&quot;&quot;</span> <span class="fu">++</span> <span class="fu">show</span> i <span class="fu">++</span> <span class="st">&quot;\&quot;];\n&quot;</span></a>
<a class="sourceLine" id="cb49-9" title="9">            toNode _ (<span class="dt">DSeq</span> a) <span class="fu">=</span> <span class="fu">show</span> a</a>
<a class="sourceLine" id="cb49-10" title="10">            toNode _ (<span class="dt">DJmp</span> a) <span class="fu">=</span> <span class="fu">show</span> a</a>
<a class="sourceLine" id="cb49-11" title="11">            toNode x <span class="dt">DDyn</span> <span class="fu">=</span> <span class="st">&quot;dyn&quot;</span> <span class="fu">++</span> <span class="fu">show</span> x</a>
<a class="sourceLine" id="cb49-12" title="12">convert <span class="dt">Disasm</span> es <span class="fu">=</span> <span class="fu">concatMap</span> go <span class="fu">$</span> S.toList es</a>
<a class="sourceLine" id="cb49-13" title="13">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb49-14" title="14">        go (x, i, <span class="dt">DSeq</span> _) <span class="fu">=</span></a>
<a class="sourceLine" id="cb49-15" title="15">            printf <span class="st">&quot;%04x %s\n&quot;</span> x (<span class="fu">show</span> i)</a>
<a class="sourceLine" id="cb49-16" title="16">        go (x, i, <span class="dt">DJmp</span> y) <span class="fu">=</span></a>
<a class="sourceLine" id="cb49-17" title="17">            printf <span class="st">&quot;%04x %s  [* %04x]\n&quot;</span> x (<span class="fu">show</span> i) y</a>
<a class="sourceLine" id="cb49-18" title="18">        go (x, i, <span class="dt">DDyn</span>) <span class="fu">=</span></a>
<a class="sourceLine" id="cb49-19" title="19">            printf <span class="st">&quot;%04x %s  [* dyn]\n&quot;</span> x (<span class="fu">show</span> i)</a></code></pre></div>
<p>For example here is an extract of the beginning of the first transputer. You can notice instructions with several destinations (conditional jumps) are displayed twice.</p>
<pre><code>80000100 AJW -76
80000102 LDC 0
80000103 STL 1
80000104 LDC 0
80000105 STL 3
80000106 MINT
80000108 LDNLP 1024
8000010b GAJW
8000010d AJW -76
8000010f LDC 201
80000111 LDPI
80000113 MINT
80000115 LDC 8
80000116 OUT
80000117 LDLP 73
80000119 MINT
8000011b LDNLP 4
8000011c LDC 12
8000011d IN
8000011e LDL 73
80000120 CJ 21
80000120 CJ 21  [* 80000137]
80000122 LDC 205
80000124 LDPI</code></pre>
<p>For the graph output, I assume that you have already seen graphviz output:</p>
<figure>
<img src="2015-08-20-a-lens-based-st20-emulator/t03.png" alt="T03 with dot driver" /><figcaption>T03 with dot driver</figcaption>
</figure>
<p>The introduction image was done using the same output but an alternative layout engines.</p>
<p>Hope you enjoyed this article!</p>]]></description>
    <pubDate>Thu, 20 Aug 2015 00:00:00 UT</pubDate>
    <guid>http://blog.emillon.org/posts/2015-08-20-a-lens-based-st20-emulator.html</guid>
    <dc:creator>Etienne Millon</dc:creator>
</item>

    </channel>
</rss>
